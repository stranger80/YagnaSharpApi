/* 
 * Yagna Market API
 *
 *  ## Yagna Market The Yagna Market is a core component of the Yagna Network, which enables computational Offers and Demands circulation. The Market is open for all entities willing to buy computations (Demands) or monetize computational resources (Offers). ## Yagna Market API The Yagna Market API is the entry to the Yagna Market through which Requestors and Providers can publish their Demands and Offers respectively, find matching counterparty, conduct negotiations and make an agreement.  This version of Market API conforms with capability level 1 of the <a href=\"https://docs.google.com/document/d/1Zny_vfgWV-hcsKS7P-Kdr3Fb0dwfl-6T_cYKVQ9mkNg\"> Market API specification</a>.  Market API contains two roles: Requestors and Providers which are symmetrical most of the time (excluding agreement phase). 
 *
 * The version of the OpenAPI document: 1.6.1
 * 
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using System.Threading;
using Golem.Common.Client.Client;
using Golem.MarketApi.Client.Model;

namespace Golem.MarketApi.Client.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IRequestorApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// CancelAgreement - Cancels Agreement.
        /// </summary>
        /// <remarks>
        /// It is only possible before Provider approved or rejected the Agreement, and before its Expiration.  Causes:   - the awaiting &#x60;approveAgreement&#x60; on Provider side to return with &#x60;Cancelled&#x60; response.   - the awaiting &#x60;waitForApproval&#x60; local call to return with &#x60;Cancelled&#x60; response. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns></returns>
        void CancelAgreement (string agreementId, Dictionary<string, Object> requestBody = default(Dictionary<string, Object>));

        /// <summary>
        /// CancelAgreement - Cancels Agreement.
        /// </summary>
        /// <remarks>
        /// It is only possible before Provider approved or rejected the Agreement, and before its Expiration.  Causes:   - the awaiting &#x60;approveAgreement&#x60; on Provider side to return with &#x60;Cancelled&#x60; response.   - the awaiting &#x60;waitForApproval&#x60; local call to return with &#x60;Cancelled&#x60; response. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> CancelAgreementWithHttpInfo (string agreementId, Dictionary<string, Object> requestBody = default(Dictionary<string, Object>));
        /// <summary>
        /// CollectAgreementEvents - Collects events related to an Agreement.
        /// </summary>
        /// <remarks>
        /// This is a blocking operation. It will not return until there is at least one new event. All events are appearing on both sides equally.  Returns Agreement related events: * &#x60;AgreementApprovedEvent&#x60; - Indicates that the Agreement has been approved   by the Provider.   - The Provider is now ready to accept a request to start an Activity     as described in the negotiated agreement.   - The Providers’s corresponding &#x60;approveAgreement&#x60; call returns &#x60;Approved&#x60;     after this event is emitted.  * &#x60;AgreementRejectedEvent&#x60; - Indicates that the Provider has called   &#x60;rejectAgreement&#x60;, which effectively stops the Agreement handshake.   The Requestor may attempt to return to the Negotiation phase by sending   a new Proposal.  * &#x60;AgreementCancelledEvent&#x60; - Indicates that the Requestor has called   &#x60;cancelAgreement&#x60;, which effectively stops the Agreement handshake.  * &#x60;AgreementTerminatedEvent&#x60; - Indicates that the Agreement has been   terminated by specified party (contains signature). 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="timeout">Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)  (optional, default to 5.0F)</param>
        /// <param name="afterTimestamp">Apply only to records created later than the specified timestamp (optional)</param>
        /// <param name="maxEvents">Maximum number of events that server should return at once.  (optional, default to 10)</param>
        /// <param name="appSessionId">A correlation/session identifier used for querying events related to an action where this appSessionId has been specified (optional)</param>
        /// <returns>List&lt;AgreementEvent&gt;</returns>
        List<AgreementEvent> CollectAgreementEvents (float? timeout = default(float?), DateTime? afterTimestamp = default(DateTime?), int? maxEvents = default(int?), string appSessionId = default(string));

        /// <summary>
        /// CollectAgreementEvents - Collects events related to an Agreement.
        /// </summary>
        /// <remarks>
        /// This is a blocking operation. It will not return until there is at least one new event. All events are appearing on both sides equally.  Returns Agreement related events: * &#x60;AgreementApprovedEvent&#x60; - Indicates that the Agreement has been approved   by the Provider.   - The Provider is now ready to accept a request to start an Activity     as described in the negotiated agreement.   - The Providers’s corresponding &#x60;approveAgreement&#x60; call returns &#x60;Approved&#x60;     after this event is emitted.  * &#x60;AgreementRejectedEvent&#x60; - Indicates that the Provider has called   &#x60;rejectAgreement&#x60;, which effectively stops the Agreement handshake.   The Requestor may attempt to return to the Negotiation phase by sending   a new Proposal.  * &#x60;AgreementCancelledEvent&#x60; - Indicates that the Requestor has called   &#x60;cancelAgreement&#x60;, which effectively stops the Agreement handshake.  * &#x60;AgreementTerminatedEvent&#x60; - Indicates that the Agreement has been   terminated by specified party (contains signature). 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="timeout">Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)  (optional, default to 5.0F)</param>
        /// <param name="afterTimestamp">Apply only to records created later than the specified timestamp (optional)</param>
        /// <param name="maxEvents">Maximum number of events that server should return at once.  (optional, default to 10)</param>
        /// <param name="appSessionId">A correlation/session identifier used for querying events related to an action where this appSessionId has been specified (optional)</param>
        /// <returns>ApiResponse of List&lt;AgreementEvent&gt;</returns>
        ApiResponse<List<AgreementEvent>> CollectAgreementEventsWithHttpInfo (float? timeout = default(float?), DateTime? afterTimestamp = default(DateTime?), int? maxEvents = default(int?), string appSessionId = default(string));
        /// <summary>
        /// CollectOffers - Reads Market responses to published Demand.
        /// </summary>
        /// <remarks>
        /// This is a blocking operation. It will not return until there is at least one new event. Returns Proposal related events: * &#x60;ProposalEvent&#x60; - Indicates that there is new Offer Proposal for this Demand. * &#x60;ProposalRejectedEvent&#x60; - Indicates that the Provider has rejected   our previous Proposal related to this Demand. This effectively ends a   Negotiation chain - it explicitly indicates that the sender will not   create another counter-Proposal.  * &#x60;PropertyQueryEvent&#x60; - not supported yet.  **Note**: When &#x60;collectOffers&#x60; is waiting, simultaneous call to &#x60;unsubscribeDemand&#x60; on the same &#x60;subscriptionId&#x60; should result in \&quot;Subscription does not exist\&quot; error returned from &#x60;collectOffers&#x60;.  **Note**: Specification requires this endpoint to support list of specific Proposal Ids to listen for messages related only to specific Proposals. This is not covered yet. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="timeout">Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)  (optional, default to 5.0F)</param>
        /// <param name="maxEvents">Maximum number of events that server should return at once.  (optional, default to 10)</param>
        /// <returns>List&lt;Event&gt;</returns>
        List<Event> CollectOffers (string subscriptionId, float? timeout = default(float?), int? maxEvents = default(int?));

        /// <summary>
        /// CollectOffers - Reads Market responses to published Demand.
        /// </summary>
        /// <remarks>
        /// This is a blocking operation. It will not return until there is at least one new event. Returns Proposal related events: * &#x60;ProposalEvent&#x60; - Indicates that there is new Offer Proposal for this Demand. * &#x60;ProposalRejectedEvent&#x60; - Indicates that the Provider has rejected   our previous Proposal related to this Demand. This effectively ends a   Negotiation chain - it explicitly indicates that the sender will not   create another counter-Proposal.  * &#x60;PropertyQueryEvent&#x60; - not supported yet.  **Note**: When &#x60;collectOffers&#x60; is waiting, simultaneous call to &#x60;unsubscribeDemand&#x60; on the same &#x60;subscriptionId&#x60; should result in \&quot;Subscription does not exist\&quot; error returned from &#x60;collectOffers&#x60;.  **Note**: Specification requires this endpoint to support list of specific Proposal Ids to listen for messages related only to specific Proposals. This is not covered yet. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="timeout">Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)  (optional, default to 5.0F)</param>
        /// <param name="maxEvents">Maximum number of events that server should return at once.  (optional, default to 10)</param>
        /// <returns>ApiResponse of List&lt;Event&gt;</returns>
        ApiResponse<List<Event>> CollectOffersWithHttpInfo (string subscriptionId, float? timeout = default(float?), int? maxEvents = default(int?));
        /// <summary>
        /// ConfirmAgreement - Sends Agreement proposal to the Provider.
        /// </summary>
        /// <remarks>
        /// Signs self-created Agreement and sends it to the Provider.  This call should immediately follow &#x60;createAgreement&#x60;. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="appSessionId">A correlation/session identifier used for querying events related to an action where this appSessionId has been specified (optional)</param>
        /// <returns></returns>
        void ConfirmAgreement (string agreementId, string appSessionId = default(string));

        /// <summary>
        /// ConfirmAgreement - Sends Agreement proposal to the Provider.
        /// </summary>
        /// <remarks>
        /// Signs self-created Agreement and sends it to the Provider.  This call should immediately follow &#x60;createAgreement&#x60;. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="appSessionId">A correlation/session identifier used for querying events related to an action where this appSessionId has been specified (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ConfirmAgreementWithHttpInfo (string agreementId, string appSessionId = default(string));
        /// <summary>
        /// CounterProposalDemand - Responds with a bespoke Demand to received Offer.
        /// </summary>
        /// <remarks>
        /// Creates and sends a modified version of original Demand (a counter-proposal) adjusted to previously received Proposal (ie. Offer). Changes Proposal state to &#x60;Draft&#x60;. Returns created Proposal id. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <param name="demandOfferBase"></param>
        /// <returns>string</returns>
        string CounterProposalDemand (string subscriptionId, string proposalId, DemandOfferBase demandOfferBase);

        /// <summary>
        /// CounterProposalDemand - Responds with a bespoke Demand to received Offer.
        /// </summary>
        /// <remarks>
        /// Creates and sends a modified version of original Demand (a counter-proposal) adjusted to previously received Proposal (ie. Offer). Changes Proposal state to &#x60;Draft&#x60;. Returns created Proposal id. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <param name="demandOfferBase"></param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> CounterProposalDemandWithHttpInfo (string subscriptionId, string proposalId, DemandOfferBase demandOfferBase);
        /// <summary>
        /// CreateAgreement - Creates Agreement from selected Proposal.
        /// </summary>
        /// <remarks>
        /// Initiates the Agreement handshake phase.  Formulates an Agreement artifact from the Proposal indicated by the received Proposal Id. Created Agreement is in &#x60;Proposal&#x60; state.  The Approval Expiry Date is added to Agreement artifact and implies the effective timeout on the whole Agreement Confirmation sequence.  A successful call to &#x60;createAgreement&#x60; shall immediately be followed by a &#x60;confirmAgreement&#x60; and &#x60;waitForApproval&#x60; call in order to listen for responses from the Provider.  **Note**: Moves given Proposal to &#x60;Approved&#x60; state. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementProposal"></param>
        /// <returns>string</returns>
        string CreateAgreement (AgreementProposal agreementProposal);

        /// <summary>
        /// CreateAgreement - Creates Agreement from selected Proposal.
        /// </summary>
        /// <remarks>
        /// Initiates the Agreement handshake phase.  Formulates an Agreement artifact from the Proposal indicated by the received Proposal Id. Created Agreement is in &#x60;Proposal&#x60; state.  The Approval Expiry Date is added to Agreement artifact and implies the effective timeout on the whole Agreement Confirmation sequence.  A successful call to &#x60;createAgreement&#x60; shall immediately be followed by a &#x60;confirmAgreement&#x60; and &#x60;waitForApproval&#x60; call in order to listen for responses from the Provider.  **Note**: Moves given Proposal to &#x60;Approved&#x60; state. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementProposal"></param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> CreateAgreementWithHttpInfo (AgreementProposal agreementProposal);
        /// <summary>
        /// GetAgreement - Fetches agreement with given agreement id.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <returns>Agreement</returns>
        Agreement GetAgreement (string agreementId);

        /// <summary>
        /// GetAgreement - Fetches agreement with given agreement id.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <returns>ApiResponse of Agreement</returns>
        ApiResponse<Agreement> GetAgreementWithHttpInfo (string agreementId);
        /// <summary>
        /// GetDemands - Fetches all active Demands which have been published by the Requestor.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>List&lt;Demand&gt;</returns>
        List<Demand> GetDemands ();

        /// <summary>
        /// GetDemands - Fetches all active Demands which have been published by the Requestor.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of List&lt;Demand&gt;</returns>
        ApiResponse<List<Demand>> GetDemandsWithHttpInfo ();
        /// <summary>
        /// GetProposalOffer - Fetches Proposal (Offer) with given id.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <returns>Proposal</returns>
        Proposal GetProposalOffer (string subscriptionId, string proposalId);

        /// <summary>
        /// GetProposalOffer - Fetches Proposal (Offer) with given id.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <returns>ApiResponse of Proposal</returns>
        ApiResponse<Proposal> GetProposalOfferWithHttpInfo (string subscriptionId, string proposalId);
        /// <summary>
        /// QueryReplyDemands - Handles dynamic property query.
        /// </summary>
        /// <remarks>
        /// Sends a response to a received property value query.  The Market Matching Mechanism, when resolving the match relation for the specific Demand-Offer pair, is to detect the “dynamic” properties required (via constraints) by the other side. At this point, it is able to query the issuing node for those properties and submit the other side’s requested properties as the context of the query.  **Note**: The property query responses may be submitted in “chunks”, ie. the responder may choose to resolve ‘quick’/lightweight’ properties faster and provide response sooner, while still working on more time-consuming properties in the background. Therefore the response contains both the resolved properties, as well as list of properties which responder knows still require resolution.  **Note**: This method must be implemented for Market API Capability Level 2. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="queryId"></param>
        /// <param name="body"></param>
        /// <returns></returns>
        void QueryReplyDemands (string subscriptionId, string queryId, Object body);

        /// <summary>
        /// QueryReplyDemands - Handles dynamic property query.
        /// </summary>
        /// <remarks>
        /// Sends a response to a received property value query.  The Market Matching Mechanism, when resolving the match relation for the specific Demand-Offer pair, is to detect the “dynamic” properties required (via constraints) by the other side. At this point, it is able to query the issuing node for those properties and submit the other side’s requested properties as the context of the query.  **Note**: The property query responses may be submitted in “chunks”, ie. the responder may choose to resolve ‘quick’/lightweight’ properties faster and provide response sooner, while still working on more time-consuming properties in the background. Therefore the response contains both the resolved properties, as well as list of properties which responder knows still require resolution.  **Note**: This method must be implemented for Market API Capability Level 2. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="queryId"></param>
        /// <param name="body"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> QueryReplyDemandsWithHttpInfo (string subscriptionId, string queryId, Object body);
        /// <summary>
        /// RejectProposalOffer - Rejects Proposal (Offer).
        /// </summary>
        /// <remarks>
        /// Effectively ends a Negotiation chain - it explicitly indicates that the sender will not create another counter-Proposal. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns></returns>
        void RejectProposalOffer (string subscriptionId, string proposalId, Reason reason = default(Reason));

        /// <summary>
        /// RejectProposalOffer - Rejects Proposal (Offer).
        /// </summary>
        /// <remarks>
        /// Effectively ends a Negotiation chain - it explicitly indicates that the sender will not create another counter-Proposal. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RejectProposalOfferWithHttpInfo (string subscriptionId, string proposalId, Reason reason = default(Reason));
        /// <summary>
        /// SubscribeDemand - Publishes Requestor capabilities via Demand.
        /// </summary>
        /// <remarks>
        /// Demand object can be considered an \&quot;open\&quot; or public Demand, as it is not directed at a specific Provider, but rather is sent to the market so that the matching mechanism implementation can associate relevant Offers.  **Note**: it is an \&quot;atomic\&quot; operation, ie. as soon as Subscription is placed, the Demand is published on the market. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="demandOfferBase"></param>
        /// <returns>string</returns>
        string SubscribeDemand (DemandOfferBase demandOfferBase);

        /// <summary>
        /// SubscribeDemand - Publishes Requestor capabilities via Demand.
        /// </summary>
        /// <remarks>
        /// Demand object can be considered an \&quot;open\&quot; or public Demand, as it is not directed at a specific Provider, but rather is sent to the market so that the matching mechanism implementation can associate relevant Offers.  **Note**: it is an \&quot;atomic\&quot; operation, ie. as soon as Subscription is placed, the Demand is published on the market. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="demandOfferBase"></param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> SubscribeDemandWithHttpInfo (DemandOfferBase demandOfferBase);
        /// <summary>
        /// TerminateAgreement - Terminates approved Agreement.
        /// </summary>
        /// <remarks>
        /// Method to finish/close the Agreement while in &#x60;Approved&#x60; state.  The other party gets notified about calling party decision to terminate a \&quot;running\&quot; agreement.  **Note**: Can be invoked at any time after Agreement was approved by both sides.  **Note**: Financial and reputational consequences are not defined by this specification. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns></returns>
        void TerminateAgreement (string agreementId, Dictionary<string, Object> requestBody = default(Dictionary<string, Object>));

        /// <summary>
        /// TerminateAgreement - Terminates approved Agreement.
        /// </summary>
        /// <remarks>
        /// Method to finish/close the Agreement while in &#x60;Approved&#x60; state.  The other party gets notified about calling party decision to terminate a \&quot;running\&quot; agreement.  **Note**: Can be invoked at any time after Agreement was approved by both sides.  **Note**: Financial and reputational consequences are not defined by this specification. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> TerminateAgreementWithHttpInfo (string agreementId, Dictionary<string, Object> requestBody = default(Dictionary<string, Object>));
        /// <summary>
        /// UnsubscribeDemand - Stop subscription for previously published Demand.
        /// </summary>
        /// <remarks>
        /// Stop receiving Proposals.  **Note**: this will terminate all pending &#x60;collectOffers&#x60; calls on this subscription. This implies, that client code should not &#x60;unsubscribeDemand&#x60; before it has received all expected/useful inputs from &#x60;collectOffers&#x60;. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <returns></returns>
        void UnsubscribeDemand (string subscriptionId);

        /// <summary>
        /// UnsubscribeDemand - Stop subscription for previously published Demand.
        /// </summary>
        /// <remarks>
        /// Stop receiving Proposals.  **Note**: this will terminate all pending &#x60;collectOffers&#x60; calls on this subscription. This implies, that client code should not &#x60;unsubscribeDemand&#x60; before it has received all expected/useful inputs from &#x60;collectOffers&#x60;. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UnsubscribeDemandWithHttpInfo (string subscriptionId);
        /// <summary>
        /// WaitForApproval - Waits for Agreement approval by the Provider.
        /// </summary>
        /// <remarks>
        /// This is a blocking operation. The call may be aborted by Requestor caller code. After the call is aborted or timed out, another &#x60;waitForApproval&#x60; call can be raised on the same Agreement Id. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="timeout">Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party&#39;s response indefinitely)  (optional, default to 5.0F)</param>
        /// <returns></returns>
        void WaitForApproval (string agreementId, float? timeout = default(float?));

        /// <summary>
        /// WaitForApproval - Waits for Agreement approval by the Provider.
        /// </summary>
        /// <remarks>
        /// This is a blocking operation. The call may be aborted by Requestor caller code. After the call is aborted or timed out, another &#x60;waitForApproval&#x60; call can be raised on the same Agreement Id. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="timeout">Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party&#39;s response indefinitely)  (optional, default to 5.0F)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> WaitForApprovalWithHttpInfo (string agreementId, float? timeout = default(float?));
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IRequestorApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// CancelAgreement - Cancels Agreement.
        /// </summary>
        /// <remarks>
        /// It is only possible before Provider approved or rejected the Agreement, and before its Expiration.  Causes:   - the awaiting &#x60;approveAgreement&#x60; on Provider side to return with &#x60;Cancelled&#x60; response.   - the awaiting &#x60;waitForApproval&#x60; local call to return with &#x60;Cancelled&#x60; response. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task CancelAgreementAsync (string agreementId, Dictionary<string, Object> requestBody = default(Dictionary<string, Object>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// CancelAgreement - Cancels Agreement.
        /// </summary>
        /// <remarks>
        /// It is only possible before Provider approved or rejected the Agreement, and before its Expiration.  Causes:   - the awaiting &#x60;approveAgreement&#x60; on Provider side to return with &#x60;Cancelled&#x60; response.   - the awaiting &#x60;waitForApproval&#x60; local call to return with &#x60;Cancelled&#x60; response. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> CancelAgreementAsyncWithHttpInfo (string agreementId, Dictionary<string, Object> requestBody = default(Dictionary<string, Object>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// CollectAgreementEvents - Collects events related to an Agreement.
        /// </summary>
        /// <remarks>
        /// This is a blocking operation. It will not return until there is at least one new event. All events are appearing on both sides equally.  Returns Agreement related events: * &#x60;AgreementApprovedEvent&#x60; - Indicates that the Agreement has been approved   by the Provider.   - The Provider is now ready to accept a request to start an Activity     as described in the negotiated agreement.   - The Providers’s corresponding &#x60;approveAgreement&#x60; call returns &#x60;Approved&#x60;     after this event is emitted.  * &#x60;AgreementRejectedEvent&#x60; - Indicates that the Provider has called   &#x60;rejectAgreement&#x60;, which effectively stops the Agreement handshake.   The Requestor may attempt to return to the Negotiation phase by sending   a new Proposal.  * &#x60;AgreementCancelledEvent&#x60; - Indicates that the Requestor has called   &#x60;cancelAgreement&#x60;, which effectively stops the Agreement handshake.  * &#x60;AgreementTerminatedEvent&#x60; - Indicates that the Agreement has been   terminated by specified party (contains signature). 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="timeout">Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)  (optional, default to 5.0F)</param>
        /// <param name="afterTimestamp">Apply only to records created later than the specified timestamp (optional)</param>
        /// <param name="maxEvents">Maximum number of events that server should return at once.  (optional, default to 10)</param>
        /// <param name="appSessionId">A correlation/session identifier used for querying events related to an action where this appSessionId has been specified (optional)</param>
        /// <returns>Task of List&lt;AgreementEvent&gt;</returns>
        System.Threading.Tasks.Task<List<AgreementEvent>> CollectAgreementEventsAsync (float? timeout = default(float?), DateTime? afterTimestamp = default(DateTime?), int? maxEvents = default(int?), string appSessionId = default(string), CancellationToken token = default(CancellationToken));

        /// <summary>
        /// CollectAgreementEvents - Collects events related to an Agreement.
        /// </summary>
        /// <remarks>
        /// This is a blocking operation. It will not return until there is at least one new event. All events are appearing on both sides equally.  Returns Agreement related events: * &#x60;AgreementApprovedEvent&#x60; - Indicates that the Agreement has been approved   by the Provider.   - The Provider is now ready to accept a request to start an Activity     as described in the negotiated agreement.   - The Providers’s corresponding &#x60;approveAgreement&#x60; call returns &#x60;Approved&#x60;     after this event is emitted.  * &#x60;AgreementRejectedEvent&#x60; - Indicates that the Provider has called   &#x60;rejectAgreement&#x60;, which effectively stops the Agreement handshake.   The Requestor may attempt to return to the Negotiation phase by sending   a new Proposal.  * &#x60;AgreementCancelledEvent&#x60; - Indicates that the Requestor has called   &#x60;cancelAgreement&#x60;, which effectively stops the Agreement handshake.  * &#x60;AgreementTerminatedEvent&#x60; - Indicates that the Agreement has been   terminated by specified party (contains signature). 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="timeout">Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)  (optional, default to 5.0F)</param>
        /// <param name="afterTimestamp">Apply only to records created later than the specified timestamp (optional)</param>
        /// <param name="maxEvents">Maximum number of events that server should return at once.  (optional, default to 10)</param>
        /// <param name="appSessionId">A correlation/session identifier used for querying events related to an action where this appSessionId has been specified (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;AgreementEvent&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<AgreementEvent>>> CollectAgreementEventsAsyncWithHttpInfo (float? timeout = default(float?), DateTime? afterTimestamp = default(DateTime?), int? maxEvents = default(int?), string appSessionId = default(string), CancellationToken token = default(CancellationToken));
        /// <summary>
        /// CollectOffers - Reads Market responses to published Demand.
        /// </summary>
        /// <remarks>
        /// This is a blocking operation. It will not return until there is at least one new event. Returns Proposal related events: * &#x60;ProposalEvent&#x60; - Indicates that there is new Offer Proposal for this Demand. * &#x60;ProposalRejectedEvent&#x60; - Indicates that the Provider has rejected   our previous Proposal related to this Demand. This effectively ends a   Negotiation chain - it explicitly indicates that the sender will not   create another counter-Proposal.  * &#x60;PropertyQueryEvent&#x60; - not supported yet.  **Note**: When &#x60;collectOffers&#x60; is waiting, simultaneous call to &#x60;unsubscribeDemand&#x60; on the same &#x60;subscriptionId&#x60; should result in \&quot;Subscription does not exist\&quot; error returned from &#x60;collectOffers&#x60;.  **Note**: Specification requires this endpoint to support list of specific Proposal Ids to listen for messages related only to specific Proposals. This is not covered yet. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="timeout">Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)  (optional, default to 5.0F)</param>
        /// <param name="maxEvents">Maximum number of events that server should return at once.  (optional, default to 10)</param>
        /// <returns>Task of List&lt;Event&gt;</returns>
        System.Threading.Tasks.Task<List<Event>> CollectOffersAsync (string subscriptionId, float? timeout = default(float?), int? maxEvents = default(int?), CancellationToken token = default(CancellationToken));

        /// <summary>
        /// CollectOffers - Reads Market responses to published Demand.
        /// </summary>
        /// <remarks>
        /// This is a blocking operation. It will not return until there is at least one new event. Returns Proposal related events: * &#x60;ProposalEvent&#x60; - Indicates that there is new Offer Proposal for this Demand. * &#x60;ProposalRejectedEvent&#x60; - Indicates that the Provider has rejected   our previous Proposal related to this Demand. This effectively ends a   Negotiation chain - it explicitly indicates that the sender will not   create another counter-Proposal.  * &#x60;PropertyQueryEvent&#x60; - not supported yet.  **Note**: When &#x60;collectOffers&#x60; is waiting, simultaneous call to &#x60;unsubscribeDemand&#x60; on the same &#x60;subscriptionId&#x60; should result in \&quot;Subscription does not exist\&quot; error returned from &#x60;collectOffers&#x60;.  **Note**: Specification requires this endpoint to support list of specific Proposal Ids to listen for messages related only to specific Proposals. This is not covered yet. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="timeout">Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)  (optional, default to 5.0F)</param>
        /// <param name="maxEvents">Maximum number of events that server should return at once.  (optional, default to 10)</param>
        /// <returns>Task of ApiResponse (List&lt;Event&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<Event>>> CollectOffersAsyncWithHttpInfo (string subscriptionId, float? timeout = default(float?), int? maxEvents = default(int?), CancellationToken token = default(CancellationToken));
        /// <summary>
        /// ConfirmAgreement - Sends Agreement proposal to the Provider.
        /// </summary>
        /// <remarks>
        /// Signs self-created Agreement and sends it to the Provider.  This call should immediately follow &#x60;createAgreement&#x60;. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="appSessionId">A correlation/session identifier used for querying events related to an action where this appSessionId has been specified (optional)</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task ConfirmAgreementAsync (string agreementId, string appSessionId = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// ConfirmAgreement - Sends Agreement proposal to the Provider.
        /// </summary>
        /// <remarks>
        /// Signs self-created Agreement and sends it to the Provider.  This call should immediately follow &#x60;createAgreement&#x60;. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="appSessionId">A correlation/session identifier used for querying events related to an action where this appSessionId has been specified (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> ConfirmAgreementAsyncWithHttpInfo (string agreementId, string appSessionId = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// CounterProposalDemand - Responds with a bespoke Demand to received Offer.
        /// </summary>
        /// <remarks>
        /// Creates and sends a modified version of original Demand (a counter-proposal) adjusted to previously received Proposal (ie. Offer). Changes Proposal state to &#x60;Draft&#x60;. Returns created Proposal id. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <param name="demandOfferBase"></param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> CounterProposalDemandAsync (string subscriptionId, string proposalId, DemandOfferBase demandOfferBase, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// CounterProposalDemand - Responds with a bespoke Demand to received Offer.
        /// </summary>
        /// <remarks>
        /// Creates and sends a modified version of original Demand (a counter-proposal) adjusted to previously received Proposal (ie. Offer). Changes Proposal state to &#x60;Draft&#x60;. Returns created Proposal id. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <param name="demandOfferBase"></param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> CounterProposalDemandAsyncWithHttpInfo (string subscriptionId, string proposalId, DemandOfferBase demandOfferBase, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// CreateAgreement - Creates Agreement from selected Proposal.
        /// </summary>
        /// <remarks>
        /// Initiates the Agreement handshake phase.  Formulates an Agreement artifact from the Proposal indicated by the received Proposal Id. Created Agreement is in &#x60;Proposal&#x60; state.  The Approval Expiry Date is added to Agreement artifact and implies the effective timeout on the whole Agreement Confirmation sequence.  A successful call to &#x60;createAgreement&#x60; shall immediately be followed by a &#x60;confirmAgreement&#x60; and &#x60;waitForApproval&#x60; call in order to listen for responses from the Provider.  **Note**: Moves given Proposal to &#x60;Approved&#x60; state. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementProposal"></param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> CreateAgreementAsync (AgreementProposal agreementProposal, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// CreateAgreement - Creates Agreement from selected Proposal.
        /// </summary>
        /// <remarks>
        /// Initiates the Agreement handshake phase.  Formulates an Agreement artifact from the Proposal indicated by the received Proposal Id. Created Agreement is in &#x60;Proposal&#x60; state.  The Approval Expiry Date is added to Agreement artifact and implies the effective timeout on the whole Agreement Confirmation sequence.  A successful call to &#x60;createAgreement&#x60; shall immediately be followed by a &#x60;confirmAgreement&#x60; and &#x60;waitForApproval&#x60; call in order to listen for responses from the Provider.  **Note**: Moves given Proposal to &#x60;Approved&#x60; state. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementProposal"></param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> CreateAgreementAsyncWithHttpInfo (AgreementProposal agreementProposal, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// GetAgreement - Fetches agreement with given agreement id.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <returns>Task of Agreement</returns>
        System.Threading.Tasks.Task<Agreement> GetAgreementAsync (string agreementId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// GetAgreement - Fetches agreement with given agreement id.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <returns>Task of ApiResponse (Agreement)</returns>
        System.Threading.Tasks.Task<ApiResponse<Agreement>> GetAgreementAsyncWithHttpInfo (string agreementId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// GetDemands - Fetches all active Demands which have been published by the Requestor.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of List&lt;Demand&gt;</returns>
        System.Threading.Tasks.Task<List<Demand>> GetDemandsAsync (System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// GetDemands - Fetches all active Demands which have been published by the Requestor.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse (List&lt;Demand&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<Demand>>> GetDemandsAsyncWithHttpInfo (System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// GetProposalOffer - Fetches Proposal (Offer) with given id.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <returns>Task of Proposal</returns>
        System.Threading.Tasks.Task<Proposal> GetProposalOfferAsync (string subscriptionId, string proposalId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// GetProposalOffer - Fetches Proposal (Offer) with given id.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <returns>Task of ApiResponse (Proposal)</returns>
        System.Threading.Tasks.Task<ApiResponse<Proposal>> GetProposalOfferAsyncWithHttpInfo (string subscriptionId, string proposalId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// QueryReplyDemands - Handles dynamic property query.
        /// </summary>
        /// <remarks>
        /// Sends a response to a received property value query.  The Market Matching Mechanism, when resolving the match relation for the specific Demand-Offer pair, is to detect the “dynamic” properties required (via constraints) by the other side. At this point, it is able to query the issuing node for those properties and submit the other side’s requested properties as the context of the query.  **Note**: The property query responses may be submitted in “chunks”, ie. the responder may choose to resolve ‘quick’/lightweight’ properties faster and provide response sooner, while still working on more time-consuming properties in the background. Therefore the response contains both the resolved properties, as well as list of properties which responder knows still require resolution.  **Note**: This method must be implemented for Market API Capability Level 2. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="queryId"></param>
        /// <param name="body"></param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task QueryReplyDemandsAsync (string subscriptionId, string queryId, Object body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// QueryReplyDemands - Handles dynamic property query.
        /// </summary>
        /// <remarks>
        /// Sends a response to a received property value query.  The Market Matching Mechanism, when resolving the match relation for the specific Demand-Offer pair, is to detect the “dynamic” properties required (via constraints) by the other side. At this point, it is able to query the issuing node for those properties and submit the other side’s requested properties as the context of the query.  **Note**: The property query responses may be submitted in “chunks”, ie. the responder may choose to resolve ‘quick’/lightweight’ properties faster and provide response sooner, while still working on more time-consuming properties in the background. Therefore the response contains both the resolved properties, as well as list of properties which responder knows still require resolution.  **Note**: This method must be implemented for Market API Capability Level 2. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="queryId"></param>
        /// <param name="body"></param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> QueryReplyDemandsAsyncWithHttpInfo (string subscriptionId, string queryId, Object body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// RejectProposalOffer - Rejects Proposal (Offer).
        /// </summary>
        /// <remarks>
        /// Effectively ends a Negotiation chain - it explicitly indicates that the sender will not create another counter-Proposal. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RejectProposalOfferAsync (string subscriptionId, string proposalId, Reason reason = default(Reason), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// RejectProposalOffer - Rejects Proposal (Offer).
        /// </summary>
        /// <remarks>
        /// Effectively ends a Negotiation chain - it explicitly indicates that the sender will not create another counter-Proposal. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RejectProposalOfferAsyncWithHttpInfo (string subscriptionId, string proposalId, Reason reason = default(Reason), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// SubscribeDemand - Publishes Requestor capabilities via Demand.
        /// </summary>
        /// <remarks>
        /// Demand object can be considered an \&quot;open\&quot; or public Demand, as it is not directed at a specific Provider, but rather is sent to the market so that the matching mechanism implementation can associate relevant Offers.  **Note**: it is an \&quot;atomic\&quot; operation, ie. as soon as Subscription is placed, the Demand is published on the market. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="demandOfferBase"></param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> SubscribeDemandAsync (DemandOfferBase demandOfferBase, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// SubscribeDemand - Publishes Requestor capabilities via Demand.
        /// </summary>
        /// <remarks>
        /// Demand object can be considered an \&quot;open\&quot; or public Demand, as it is not directed at a specific Provider, but rather is sent to the market so that the matching mechanism implementation can associate relevant Offers.  **Note**: it is an \&quot;atomic\&quot; operation, ie. as soon as Subscription is placed, the Demand is published on the market. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="demandOfferBase"></param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> SubscribeDemandAsyncWithHttpInfo (DemandOfferBase demandOfferBase, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// TerminateAgreement - Terminates approved Agreement.
        /// </summary>
        /// <remarks>
        /// Method to finish/close the Agreement while in &#x60;Approved&#x60; state.  The other party gets notified about calling party decision to terminate a \&quot;running\&quot; agreement.  **Note**: Can be invoked at any time after Agreement was approved by both sides.  **Note**: Financial and reputational consequences are not defined by this specification. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task TerminateAgreementAsync (string agreementId, Dictionary<string, Object> requestBody = default(Dictionary<string, Object>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// TerminateAgreement - Terminates approved Agreement.
        /// </summary>
        /// <remarks>
        /// Method to finish/close the Agreement while in &#x60;Approved&#x60; state.  The other party gets notified about calling party decision to terminate a \&quot;running\&quot; agreement.  **Note**: Can be invoked at any time after Agreement was approved by both sides.  **Note**: Financial and reputational consequences are not defined by this specification. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> TerminateAgreementAsyncWithHttpInfo (string agreementId, Dictionary<string, Object> requestBody = default(Dictionary<string, Object>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// UnsubscribeDemand - Stop subscription for previously published Demand.
        /// </summary>
        /// <remarks>
        /// Stop receiving Proposals.  **Note**: this will terminate all pending &#x60;collectOffers&#x60; calls on this subscription. This implies, that client code should not &#x60;unsubscribeDemand&#x60; before it has received all expected/useful inputs from &#x60;collectOffers&#x60;. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task UnsubscribeDemandAsync (string subscriptionId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// UnsubscribeDemand - Stop subscription for previously published Demand.
        /// </summary>
        /// <remarks>
        /// Stop receiving Proposals.  **Note**: this will terminate all pending &#x60;collectOffers&#x60; calls on this subscription. This implies, that client code should not &#x60;unsubscribeDemand&#x60; before it has received all expected/useful inputs from &#x60;collectOffers&#x60;. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> UnsubscribeDemandAsyncWithHttpInfo (string subscriptionId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// WaitForApproval - Waits for Agreement approval by the Provider.
        /// </summary>
        /// <remarks>
        /// This is a blocking operation. The call may be aborted by Requestor caller code. After the call is aborted or timed out, another &#x60;waitForApproval&#x60; call can be raised on the same Agreement Id. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="timeout">Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party&#39;s response indefinitely)  (optional, default to 5.0F)</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task WaitForApprovalAsync (string agreementId, float? timeout = default(float?), CancellationToken token = default(CancellationToken));

        /// <summary>
        /// WaitForApproval - Waits for Agreement approval by the Provider.
        /// </summary>
        /// <remarks>
        /// This is a blocking operation. The call may be aborted by Requestor caller code. After the call is aborted or timed out, another &#x60;waitForApproval&#x60; call can be raised on the same Agreement Id. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="timeout">Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party&#39;s response indefinitely)  (optional, default to 5.0F)</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> WaitForApprovalAsyncWithHttpInfo (string agreementId, float? timeout = default(float?), CancellationToken token = default(CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IRequestorApi : IRequestorApiSync, IRequestorApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class RequestorApi : IRequestorApi
    {
        private Golem.Common.Client.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="RequestorApi"/> class.
        /// </summary>
        /// <returns></returns>
        public RequestorApi() : this((string) null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RequestorApi"/> class.
        /// </summary>
        /// <returns></returns>
        public RequestorApi(String basePath)
        {
            this.Configuration = Golem.Common.Client.Client.Configuration.MergeConfigurations(
                Golem.Common.Client.Client.GlobalConfiguration.Instance,
                new Golem.Common.Client.Client.Configuration { BasePath = basePath }
            );
            this.Client = new Golem.Common.Client.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Golem.Common.Client.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = Golem.Common.Client.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RequestorApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public RequestorApi(Golem.Common.Client.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = Golem.Common.Client.Client.Configuration.MergeConfigurations(
                Golem.Common.Client.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new Golem.Common.Client.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Golem.Common.Client.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = Golem.Common.Client.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RequestorApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public RequestorApi(Golem.Common.Client.Client.ISynchronousClient client,Golem.Common.Client.Client.IAsynchronousClient asyncClient, Golem.Common.Client.Client.IReadableConfiguration configuration)
        {
            if(client == null) throw new ArgumentNullException("client");
            if(asyncClient == null) throw new ArgumentNullException("asyncClient");
            if(configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = Golem.Common.Client.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public Golem.Common.Client.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public Golem.Common.Client.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Golem.Common.Client.Client.IReadableConfiguration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Golem.Common.Client.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// CancelAgreement - Cancels Agreement. It is only possible before Provider approved or rejected the Agreement, and before its Expiration.  Causes:   - the awaiting &#x60;approveAgreement&#x60; on Provider side to return with &#x60;Cancelled&#x60; response.   - the awaiting &#x60;waitForApproval&#x60; local call to return with &#x60;Cancelled&#x60; response. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns></returns>
        public void CancelAgreement (string agreementId, Dictionary<string, Object> requestBody = default(Dictionary<string, Object>))
        {
             CancelAgreementWithHttpInfo(agreementId, requestBody);
        }

        /// <summary>
        /// CancelAgreement - Cancels Agreement. It is only possible before Provider approved or rejected the Agreement, and before its Expiration.  Causes:   - the awaiting &#x60;approveAgreement&#x60; on Provider side to return with &#x60;Cancelled&#x60; response.   - the awaiting &#x60;waitForApproval&#x60; local call to return with &#x60;Cancelled&#x60; response. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Golem.Common.Client.Client.ApiResponse<Object> CancelAgreementWithHttpInfo (string agreementId, Dictionary<string, Object> requestBody = default(Dictionary<string, Object>))
        {
            // verify the required parameter 'agreementId' is set
            if (agreementId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'agreementId' when calling RequestorApi->CancelAgreement");

            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Golem.Common.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Golem.Common.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (agreementId != null)
                localVarRequestOptions.PathParameters.Add("agreementId", Golem.Common.Client.Client.ClientUtils.ParameterToString(agreementId)); // path parameter
            localVarRequestOptions.Data = requestBody;

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/agreements/{agreementId}/cancel", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CancelAgreement", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// CancelAgreement - Cancels Agreement. It is only possible before Provider approved or rejected the Agreement, and before its Expiration.  Causes:   - the awaiting &#x60;approveAgreement&#x60; on Provider side to return with &#x60;Cancelled&#x60; response.   - the awaiting &#x60;waitForApproval&#x60; local call to return with &#x60;Cancelled&#x60; response. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task CancelAgreementAsync (string agreementId, Dictionary<string, Object> requestBody = default(Dictionary<string, Object>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
             await CancelAgreementAsyncWithHttpInfo(agreementId, requestBody, cancellationToken);

        }

        /// <summary>
        /// CancelAgreement - Cancels Agreement. It is only possible before Provider approved or rejected the Agreement, and before its Expiration.  Causes:   - the awaiting &#x60;approveAgreement&#x60; on Provider side to return with &#x60;Cancelled&#x60; response.   - the awaiting &#x60;waitForApproval&#x60; local call to return with &#x60;Cancelled&#x60; response. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Golem.Common.Client.Client.ApiResponse<Object>> CancelAgreementAsyncWithHttpInfo (string agreementId, Dictionary<string, Object> requestBody = default(Dictionary<string, Object>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'agreementId' is set
            if (agreementId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'agreementId' when calling RequestorApi->CancelAgreement");


            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };
            
            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);
            
            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);
            
            if (agreementId != null)
                localVarRequestOptions.PathParameters.Add("agreementId", Golem.Common.Client.Client.ClientUtils.ParameterToString(agreementId)); // path parameter
            localVarRequestOptions.Data = requestBody;

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/agreements/{agreementId}/cancel", localVarRequestOptions, this.Configuration, cancellationToken);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CancelAgreement", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// CollectAgreementEvents - Collects events related to an Agreement. This is a blocking operation. It will not return until there is at least one new event. All events are appearing on both sides equally.  Returns Agreement related events: * &#x60;AgreementApprovedEvent&#x60; - Indicates that the Agreement has been approved   by the Provider.   - The Provider is now ready to accept a request to start an Activity     as described in the negotiated agreement.   - The Providers’s corresponding &#x60;approveAgreement&#x60; call returns &#x60;Approved&#x60;     after this event is emitted.  * &#x60;AgreementRejectedEvent&#x60; - Indicates that the Provider has called   &#x60;rejectAgreement&#x60;, which effectively stops the Agreement handshake.   The Requestor may attempt to return to the Negotiation phase by sending   a new Proposal.  * &#x60;AgreementCancelledEvent&#x60; - Indicates that the Requestor has called   &#x60;cancelAgreement&#x60;, which effectively stops the Agreement handshake.  * &#x60;AgreementTerminatedEvent&#x60; - Indicates that the Agreement has been   terminated by specified party (contains signature). 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="timeout">Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)  (optional, default to 5.0F)</param>
        /// <param name="afterTimestamp">Apply only to records created later than the specified timestamp (optional)</param>
        /// <param name="maxEvents">Maximum number of events that server should return at once.  (optional, default to 10)</param>
        /// <param name="appSessionId">A correlation/session identifier used for querying events related to an action where this appSessionId has been specified (optional)</param>
        /// <returns>List&lt;AgreementEvent&gt;</returns>
        public List<AgreementEvent> CollectAgreementEvents (float? timeout = default(float?), DateTime? afterTimestamp = default(DateTime?), int? maxEvents = default(int?), string appSessionId = default(string))
        {
             Golem.Common.Client.Client.ApiResponse<List<AgreementEvent>> localVarResponse = CollectAgreementEventsWithHttpInfo(timeout, afterTimestamp, maxEvents, appSessionId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// CollectAgreementEvents - Collects events related to an Agreement. This is a blocking operation. It will not return until there is at least one new event. All events are appearing on both sides equally.  Returns Agreement related events: * &#x60;AgreementApprovedEvent&#x60; - Indicates that the Agreement has been approved   by the Provider.   - The Provider is now ready to accept a request to start an Activity     as described in the negotiated agreement.   - The Providers’s corresponding &#x60;approveAgreement&#x60; call returns &#x60;Approved&#x60;     after this event is emitted.  * &#x60;AgreementRejectedEvent&#x60; - Indicates that the Provider has called   &#x60;rejectAgreement&#x60;, which effectively stops the Agreement handshake.   The Requestor may attempt to return to the Negotiation phase by sending   a new Proposal.  * &#x60;AgreementCancelledEvent&#x60; - Indicates that the Requestor has called   &#x60;cancelAgreement&#x60;, which effectively stops the Agreement handshake.  * &#x60;AgreementTerminatedEvent&#x60; - Indicates that the Agreement has been   terminated by specified party (contains signature). 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="timeout">Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)  (optional, default to 5.0F)</param>
        /// <param name="afterTimestamp">Apply only to records created later than the specified timestamp (optional)</param>
        /// <param name="maxEvents">Maximum number of events that server should return at once.  (optional, default to 10)</param>
        /// <param name="appSessionId">A correlation/session identifier used for querying events related to an action where this appSessionId has been specified (optional)</param>
        /// <returns>ApiResponse of List&lt;AgreementEvent&gt;</returns>
        public Golem.Common.Client.Client.ApiResponse< List<AgreementEvent> > CollectAgreementEventsWithHttpInfo (float? timeout = default(float?), DateTime? afterTimestamp = default(DateTime?), int? maxEvents = default(int?), string appSessionId = default(string))
        {
            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Golem.Common.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Golem.Common.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (timeout != null)
            {
                localVarRequestOptions.QueryParameters.Add(Golem.Common.Client.Client.ClientUtils.ParameterToMultiMap("", "timeout", timeout));
            }
            if (afterTimestamp != null)
            {
                localVarRequestOptions.QueryParameters.Add(Golem.Common.Client.Client.ClientUtils.ParameterToMultiMap("", "afterTimestamp", afterTimestamp));
            }
            if (maxEvents != null)
            {
                localVarRequestOptions.QueryParameters.Add(Golem.Common.Client.Client.ClientUtils.ParameterToMultiMap("", "maxEvents", maxEvents));
            }
            if (appSessionId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Golem.Common.Client.Client.ClientUtils.ParameterToMultiMap("", "appSessionId", appSessionId));
            }

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get< List<AgreementEvent> >("/agreementEvents", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CollectAgreementEvents", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// CollectAgreementEvents - Collects events related to an Agreement. This is a blocking operation. It will not return until there is at least one new event. All events are appearing on both sides equally.  Returns Agreement related events: * &#x60;AgreementApprovedEvent&#x60; - Indicates that the Agreement has been approved   by the Provider.   - The Provider is now ready to accept a request to start an Activity     as described in the negotiated agreement.   - The Providers’s corresponding &#x60;approveAgreement&#x60; call returns &#x60;Approved&#x60;     after this event is emitted.  * &#x60;AgreementRejectedEvent&#x60; - Indicates that the Provider has called   &#x60;rejectAgreement&#x60;, which effectively stops the Agreement handshake.   The Requestor may attempt to return to the Negotiation phase by sending   a new Proposal.  * &#x60;AgreementCancelledEvent&#x60; - Indicates that the Requestor has called   &#x60;cancelAgreement&#x60;, which effectively stops the Agreement handshake.  * &#x60;AgreementTerminatedEvent&#x60; - Indicates that the Agreement has been   terminated by specified party (contains signature). 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="timeout">Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)  (optional, default to 5.0F)</param>
        /// <param name="afterTimestamp">Apply only to records created later than the specified timestamp (optional)</param>
        /// <param name="maxEvents">Maximum number of events that server should return at once.  (optional, default to 10)</param>
        /// <param name="appSessionId">A correlation/session identifier used for querying events related to an action where this appSessionId has been specified (optional)</param>
        /// <returns>Task of List&lt;AgreementEvent&gt;</returns>
        public async System.Threading.Tasks.Task<List<AgreementEvent>> CollectAgreementEventsAsync (float? timeout = default(float?), DateTime? afterTimestamp = default(DateTime?), int? maxEvents = default(int?), string appSessionId = default(string), CancellationToken token = default(CancellationToken))
        {
             Golem.Common.Client.Client.ApiResponse<List<AgreementEvent>> localVarResponse = await CollectAgreementEventsAsyncWithHttpInfo(timeout, afterTimestamp, maxEvents, appSessionId, token);
             return localVarResponse.Data;

        }

        /// <summary>
        /// CollectAgreementEvents - Collects events related to an Agreement. This is a blocking operation. It will not return until there is at least one new event. All events are appearing on both sides equally.  Returns Agreement related events: * &#x60;AgreementApprovedEvent&#x60; - Indicates that the Agreement has been approved   by the Provider.   - The Provider is now ready to accept a request to start an Activity     as described in the negotiated agreement.   - The Providers’s corresponding &#x60;approveAgreement&#x60; call returns &#x60;Approved&#x60;     after this event is emitted.  * &#x60;AgreementRejectedEvent&#x60; - Indicates that the Provider has called   &#x60;rejectAgreement&#x60;, which effectively stops the Agreement handshake.   The Requestor may attempt to return to the Negotiation phase by sending   a new Proposal.  * &#x60;AgreementCancelledEvent&#x60; - Indicates that the Requestor has called   &#x60;cancelAgreement&#x60;, which effectively stops the Agreement handshake.  * &#x60;AgreementTerminatedEvent&#x60; - Indicates that the Agreement has been   terminated by specified party (contains signature). 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="timeout">Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)  (optional, default to 5.0F)</param>
        /// <param name="afterTimestamp">Apply only to records created later than the specified timestamp (optional)</param>
        /// <param name="maxEvents">Maximum number of events that server should return at once.  (optional, default to 10)</param>
        /// <param name="appSessionId">A correlation/session identifier used for querying events related to an action where this appSessionId has been specified (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;AgreementEvent&gt;)</returns>
        public async System.Threading.Tasks.Task<Golem.Common.Client.Client.ApiResponse<List<AgreementEvent>>> CollectAgreementEventsAsyncWithHttpInfo (float? timeout = default(float?), DateTime? afterTimestamp = default(DateTime?), int? maxEvents = default(int?), string appSessionId = default(string), CancellationToken token = default(CancellationToken))
        {

            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };
            
            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);
            
            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);
            
            if (timeout != null)
            {
                localVarRequestOptions.QueryParameters.Add(Golem.Common.Client.Client.ClientUtils.ParameterToMultiMap("", "timeout", timeout));
            }
            if (afterTimestamp != null)
            {
                localVarRequestOptions.QueryParameters.Add(Golem.Common.Client.Client.ClientUtils.ParameterToMultiMap("", "afterTimestamp", afterTimestamp));
            }
            if (maxEvents != null)
            {
                localVarRequestOptions.QueryParameters.Add(Golem.Common.Client.Client.ClientUtils.ParameterToMultiMap("", "maxEvents", maxEvents));
            }
            if (appSessionId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Golem.Common.Client.Client.ClientUtils.ParameterToMultiMap("", "appSessionId", appSessionId));
            }

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<AgreementEvent>>("/agreementEvents", localVarRequestOptions, this.Configuration, token);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CollectAgreementEvents", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// CollectOffers - Reads Market responses to published Demand. This is a blocking operation. It will not return until there is at least one new event. Returns Proposal related events: * &#x60;ProposalEvent&#x60; - Indicates that there is new Offer Proposal for this Demand. * &#x60;ProposalRejectedEvent&#x60; - Indicates that the Provider has rejected   our previous Proposal related to this Demand. This effectively ends a   Negotiation chain - it explicitly indicates that the sender will not   create another counter-Proposal.  * &#x60;PropertyQueryEvent&#x60; - not supported yet.  **Note**: When &#x60;collectOffers&#x60; is waiting, simultaneous call to &#x60;unsubscribeDemand&#x60; on the same &#x60;subscriptionId&#x60; should result in \&quot;Subscription does not exist\&quot; error returned from &#x60;collectOffers&#x60;.  **Note**: Specification requires this endpoint to support list of specific Proposal Ids to listen for messages related only to specific Proposals. This is not covered yet. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="timeout">Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)  (optional, default to 5.0F)</param>
        /// <param name="maxEvents">Maximum number of events that server should return at once.  (optional, default to 10)</param>
        /// <returns>List&lt;Event&gt;</returns>
        public List<Event> CollectOffers (string subscriptionId, float? timeout = default(float?), int? maxEvents = default(int?))
        {
             Golem.Common.Client.Client.ApiResponse<List<Event>> localVarResponse = CollectOffersWithHttpInfo(subscriptionId, timeout, maxEvents);
             return localVarResponse.Data;
        }

        /// <summary>
        /// CollectOffers - Reads Market responses to published Demand. This is a blocking operation. It will not return until there is at least one new event. Returns Proposal related events: * &#x60;ProposalEvent&#x60; - Indicates that there is new Offer Proposal for this Demand. * &#x60;ProposalRejectedEvent&#x60; - Indicates that the Provider has rejected   our previous Proposal related to this Demand. This effectively ends a   Negotiation chain - it explicitly indicates that the sender will not   create another counter-Proposal.  * &#x60;PropertyQueryEvent&#x60; - not supported yet.  **Note**: When &#x60;collectOffers&#x60; is waiting, simultaneous call to &#x60;unsubscribeDemand&#x60; on the same &#x60;subscriptionId&#x60; should result in \&quot;Subscription does not exist\&quot; error returned from &#x60;collectOffers&#x60;.  **Note**: Specification requires this endpoint to support list of specific Proposal Ids to listen for messages related only to specific Proposals. This is not covered yet. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="timeout">Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)  (optional, default to 5.0F)</param>
        /// <param name="maxEvents">Maximum number of events that server should return at once.  (optional, default to 10)</param>
        /// <returns>ApiResponse of List&lt;Event&gt;</returns>
        public Golem.Common.Client.Client.ApiResponse< List<Event> > CollectOffersWithHttpInfo (string subscriptionId, float? timeout = default(float?), int? maxEvents = default(int?))
        {
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'subscriptionId' when calling RequestorApi->CollectOffers");

            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Golem.Common.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Golem.Common.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (subscriptionId != null)
                localVarRequestOptions.PathParameters.Add("subscriptionId", Golem.Common.Client.Client.ClientUtils.ParameterToString(subscriptionId)); // path parameter
            if (timeout != null)
            {
                localVarRequestOptions.QueryParameters.Add(Golem.Common.Client.Client.ClientUtils.ParameterToMultiMap("", "timeout", timeout));
            }
            if (maxEvents != null)
            {
                localVarRequestOptions.QueryParameters.Add(Golem.Common.Client.Client.ClientUtils.ParameterToMultiMap("", "maxEvents", maxEvents));
            }

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get< List<Event> >("/demands/{subscriptionId}/events", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CollectOffers", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// CollectOffers - Reads Market responses to published Demand. This is a blocking operation. It will not return until there is at least one new event. Returns Proposal related events: * &#x60;ProposalEvent&#x60; - Indicates that there is new Offer Proposal for this Demand. * &#x60;ProposalRejectedEvent&#x60; - Indicates that the Provider has rejected   our previous Proposal related to this Demand. This effectively ends a   Negotiation chain - it explicitly indicates that the sender will not   create another counter-Proposal.  * &#x60;PropertyQueryEvent&#x60; - not supported yet.  **Note**: When &#x60;collectOffers&#x60; is waiting, simultaneous call to &#x60;unsubscribeDemand&#x60; on the same &#x60;subscriptionId&#x60; should result in \&quot;Subscription does not exist\&quot; error returned from &#x60;collectOffers&#x60;.  **Note**: Specification requires this endpoint to support list of specific Proposal Ids to listen for messages related only to specific Proposals. This is not covered yet. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="timeout">Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)  (optional, default to 5.0F)</param>
        /// <param name="maxEvents">Maximum number of events that server should return at once.  (optional, default to 10)</param>
        /// <returns>Task of List&lt;Event&gt;</returns>
        public async System.Threading.Tasks.Task<List<Event>> CollectOffersAsync (string subscriptionId, float? timeout = default(float?), int? maxEvents = default(int?), CancellationToken token = default(CancellationToken))
        {
             Golem.Common.Client.Client.ApiResponse<List<Event>> localVarResponse = await CollectOffersAsyncWithHttpInfo(subscriptionId, timeout, maxEvents, token);
             return localVarResponse.Data;

        }

        /// <summary>
        /// CollectOffers - Reads Market responses to published Demand. This is a blocking operation. It will not return until there is at least one new event. Returns Proposal related events: * &#x60;ProposalEvent&#x60; - Indicates that there is new Offer Proposal for this Demand. * &#x60;ProposalRejectedEvent&#x60; - Indicates that the Provider has rejected   our previous Proposal related to this Demand. This effectively ends a   Negotiation chain - it explicitly indicates that the sender will not   create another counter-Proposal.  * &#x60;PropertyQueryEvent&#x60; - not supported yet.  **Note**: When &#x60;collectOffers&#x60; is waiting, simultaneous call to &#x60;unsubscribeDemand&#x60; on the same &#x60;subscriptionId&#x60; should result in \&quot;Subscription does not exist\&quot; error returned from &#x60;collectOffers&#x60;.  **Note**: Specification requires this endpoint to support list of specific Proposal Ids to listen for messages related only to specific Proposals. This is not covered yet. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="timeout">Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)  (optional, default to 5.0F)</param>
        /// <param name="maxEvents">Maximum number of events that server should return at once.  (optional, default to 10)</param>
        /// <returns>Task of ApiResponse (List&lt;Event&gt;)</returns>
        public async System.Threading.Tasks.Task<Golem.Common.Client.Client.ApiResponse<List<Event>>> CollectOffersAsyncWithHttpInfo (string subscriptionId, float? timeout = default(float?), int? maxEvents = default(int?), CancellationToken token = default(CancellationToken))
        {
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'subscriptionId' when calling RequestorApi->CollectOffers");


            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };
            
            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);
            
            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);
            
            if (subscriptionId != null)
                localVarRequestOptions.PathParameters.Add("subscriptionId", Golem.Common.Client.Client.ClientUtils.ParameterToString(subscriptionId)); // path parameter
            if (timeout != null)
            {
                localVarRequestOptions.QueryParameters.Add(Golem.Common.Client.Client.ClientUtils.ParameterToMultiMap("", "timeout", timeout));
            }
            if (maxEvents != null)
            {
                localVarRequestOptions.QueryParameters.Add(Golem.Common.Client.Client.ClientUtils.ParameterToMultiMap("", "maxEvents", maxEvents));
            }

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<Event>>("/demands/{subscriptionId}/events", localVarRequestOptions, this.Configuration, token);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CollectOffers", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// ConfirmAgreement - Sends Agreement proposal to the Provider. Signs self-created Agreement and sends it to the Provider.  This call should immediately follow &#x60;createAgreement&#x60;. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="appSessionId">A correlation/session identifier used for querying events related to an action where this appSessionId has been specified (optional)</param>
        /// <returns></returns>
        public void ConfirmAgreement (string agreementId, string appSessionId = default(string))
        {
             ConfirmAgreementWithHttpInfo(agreementId, appSessionId);
        }

        /// <summary>
        /// ConfirmAgreement - Sends Agreement proposal to the Provider. Signs self-created Agreement and sends it to the Provider.  This call should immediately follow &#x60;createAgreement&#x60;. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="appSessionId">A correlation/session identifier used for querying events related to an action where this appSessionId has been specified (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Golem.Common.Client.Client.ApiResponse<Object> ConfirmAgreementWithHttpInfo (string agreementId, string appSessionId = default(string))
        {
            // verify the required parameter 'agreementId' is set
            if (agreementId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'agreementId' when calling RequestorApi->ConfirmAgreement");

            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Golem.Common.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Golem.Common.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (agreementId != null)
                localVarRequestOptions.PathParameters.Add("agreementId", Golem.Common.Client.Client.ClientUtils.ParameterToString(agreementId)); // path parameter
            if (appSessionId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Golem.Common.Client.Client.ClientUtils.ParameterToMultiMap("", "appSessionId", appSessionId));
            }

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/agreements/{agreementId}/confirm", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ConfirmAgreement", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// ConfirmAgreement - Sends Agreement proposal to the Provider. Signs self-created Agreement and sends it to the Provider.  This call should immediately follow &#x60;createAgreement&#x60;. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="appSessionId">A correlation/session identifier used for querying events related to an action where this appSessionId has been specified (optional)</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task ConfirmAgreementAsync (string agreementId, string appSessionId = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
             await ConfirmAgreementAsyncWithHttpInfo(agreementId, appSessionId, cancellationToken);

        }

        /// <summary>
        /// ConfirmAgreement - Sends Agreement proposal to the Provider. Signs self-created Agreement and sends it to the Provider.  This call should immediately follow &#x60;createAgreement&#x60;. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="appSessionId">A correlation/session identifier used for querying events related to an action where this appSessionId has been specified (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Golem.Common.Client.Client.ApiResponse<Object>> ConfirmAgreementAsyncWithHttpInfo (string agreementId, string appSessionId = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'agreementId' is set
            if (agreementId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'agreementId' when calling RequestorApi->ConfirmAgreement");


            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };
            
            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);
            
            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);
            
            if (agreementId != null)
                localVarRequestOptions.PathParameters.Add("agreementId", Golem.Common.Client.Client.ClientUtils.ParameterToString(agreementId)); // path parameter
            if (appSessionId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Golem.Common.Client.Client.ClientUtils.ParameterToMultiMap("", "appSessionId", appSessionId));
            }

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/agreements/{agreementId}/confirm", localVarRequestOptions, this.Configuration, cancellationToken);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ConfirmAgreement", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// CounterProposalDemand - Responds with a bespoke Demand to received Offer. Creates and sends a modified version of original Demand (a counter-proposal) adjusted to previously received Proposal (ie. Offer). Changes Proposal state to &#x60;Draft&#x60;. Returns created Proposal id. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <param name="demandOfferBase"></param>
        /// <returns>string</returns>
        public string CounterProposalDemand (string subscriptionId, string proposalId, DemandOfferBase demandOfferBase)
        {
             Golem.Common.Client.Client.ApiResponse<string> localVarResponse = CounterProposalDemandWithHttpInfo(subscriptionId, proposalId, demandOfferBase);
             return localVarResponse.Data;
        }

        /// <summary>
        /// CounterProposalDemand - Responds with a bespoke Demand to received Offer. Creates and sends a modified version of original Demand (a counter-proposal) adjusted to previously received Proposal (ie. Offer). Changes Proposal state to &#x60;Draft&#x60;. Returns created Proposal id. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <param name="demandOfferBase"></param>
        /// <returns>ApiResponse of string</returns>
        public Golem.Common.Client.Client.ApiResponse< string > CounterProposalDemandWithHttpInfo (string subscriptionId, string proposalId, DemandOfferBase demandOfferBase)
        {
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'subscriptionId' when calling RequestorApi->CounterProposalDemand");

            // verify the required parameter 'proposalId' is set
            if (proposalId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'proposalId' when calling RequestorApi->CounterProposalDemand");

            // verify the required parameter 'demandOfferBase' is set
            if (demandOfferBase == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'demandOfferBase' when calling RequestorApi->CounterProposalDemand");

            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Golem.Common.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Golem.Common.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (subscriptionId != null)
                localVarRequestOptions.PathParameters.Add("subscriptionId", Golem.Common.Client.Client.ClientUtils.ParameterToString(subscriptionId)); // path parameter
            if (proposalId != null)
                localVarRequestOptions.PathParameters.Add("proposalId", Golem.Common.Client.Client.ClientUtils.ParameterToString(proposalId)); // path parameter
            localVarRequestOptions.Data = demandOfferBase;

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post< string >("/demands/{subscriptionId}/proposals/{proposalId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CounterProposalDemand", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// CounterProposalDemand - Responds with a bespoke Demand to received Offer. Creates and sends a modified version of original Demand (a counter-proposal) adjusted to previously received Proposal (ie. Offer). Changes Proposal state to &#x60;Draft&#x60;. Returns created Proposal id. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <param name="demandOfferBase"></param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> CounterProposalDemandAsync (string subscriptionId, string proposalId, DemandOfferBase demandOfferBase, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
             Golem.Common.Client.Client.ApiResponse<string> localVarResponse = await CounterProposalDemandAsyncWithHttpInfo(subscriptionId, proposalId, demandOfferBase, cancellationToken);
             return localVarResponse.Data;

        }

        /// <summary>
        /// CounterProposalDemand - Responds with a bespoke Demand to received Offer. Creates and sends a modified version of original Demand (a counter-proposal) adjusted to previously received Proposal (ie. Offer). Changes Proposal state to &#x60;Draft&#x60;. Returns created Proposal id. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <param name="demandOfferBase"></param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<Golem.Common.Client.Client.ApiResponse<string>> CounterProposalDemandAsyncWithHttpInfo (string subscriptionId, string proposalId, DemandOfferBase demandOfferBase, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'subscriptionId' when calling RequestorApi->CounterProposalDemand");

            // verify the required parameter 'proposalId' is set
            if (proposalId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'proposalId' when calling RequestorApi->CounterProposalDemand");

            // verify the required parameter 'demandOfferBase' is set
            if (demandOfferBase == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'demandOfferBase' when calling RequestorApi->CounterProposalDemand");


            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };
            
            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);
            
            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);
            
            if (subscriptionId != null)
                localVarRequestOptions.PathParameters.Add("subscriptionId", Golem.Common.Client.Client.ClientUtils.ParameterToString(subscriptionId)); // path parameter
            if (proposalId != null)
                localVarRequestOptions.PathParameters.Add("proposalId", Golem.Common.Client.Client.ClientUtils.ParameterToString(proposalId)); // path parameter
            localVarRequestOptions.Data = demandOfferBase;

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<string>("/demands/{subscriptionId}/proposals/{proposalId}", localVarRequestOptions, this.Configuration, cancellationToken);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CounterProposalDemand", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// CreateAgreement - Creates Agreement from selected Proposal. Initiates the Agreement handshake phase.  Formulates an Agreement artifact from the Proposal indicated by the received Proposal Id. Created Agreement is in &#x60;Proposal&#x60; state.  The Approval Expiry Date is added to Agreement artifact and implies the effective timeout on the whole Agreement Confirmation sequence.  A successful call to &#x60;createAgreement&#x60; shall immediately be followed by a &#x60;confirmAgreement&#x60; and &#x60;waitForApproval&#x60; call in order to listen for responses from the Provider.  **Note**: Moves given Proposal to &#x60;Approved&#x60; state. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementProposal"></param>
        /// <returns>string</returns>
        public string CreateAgreement (AgreementProposal agreementProposal)
        {
             Golem.Common.Client.Client.ApiResponse<string> localVarResponse = CreateAgreementWithHttpInfo(agreementProposal);
             return localVarResponse.Data;
        }

        /// <summary>
        /// CreateAgreement - Creates Agreement from selected Proposal. Initiates the Agreement handshake phase.  Formulates an Agreement artifact from the Proposal indicated by the received Proposal Id. Created Agreement is in &#x60;Proposal&#x60; state.  The Approval Expiry Date is added to Agreement artifact and implies the effective timeout on the whole Agreement Confirmation sequence.  A successful call to &#x60;createAgreement&#x60; shall immediately be followed by a &#x60;confirmAgreement&#x60; and &#x60;waitForApproval&#x60; call in order to listen for responses from the Provider.  **Note**: Moves given Proposal to &#x60;Approved&#x60; state. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementProposal"></param>
        /// <returns>ApiResponse of string</returns>
        public Golem.Common.Client.Client.ApiResponse< string > CreateAgreementWithHttpInfo (AgreementProposal agreementProposal)
        {
            // verify the required parameter 'agreementProposal' is set
            if (agreementProposal == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'agreementProposal' when calling RequestorApi->CreateAgreement");

            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Golem.Common.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Golem.Common.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = agreementProposal;

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post< string >("/agreements", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateAgreement", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// CreateAgreement - Creates Agreement from selected Proposal. Initiates the Agreement handshake phase.  Formulates an Agreement artifact from the Proposal indicated by the received Proposal Id. Created Agreement is in &#x60;Proposal&#x60; state.  The Approval Expiry Date is added to Agreement artifact and implies the effective timeout on the whole Agreement Confirmation sequence.  A successful call to &#x60;createAgreement&#x60; shall immediately be followed by a &#x60;confirmAgreement&#x60; and &#x60;waitForApproval&#x60; call in order to listen for responses from the Provider.  **Note**: Moves given Proposal to &#x60;Approved&#x60; state. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementProposal"></param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> CreateAgreementAsync (AgreementProposal agreementProposal, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
             Golem.Common.Client.Client.ApiResponse<string> localVarResponse = await CreateAgreementAsyncWithHttpInfo(agreementProposal, cancellationToken);
             return localVarResponse.Data;

        }

        /// <summary>
        /// CreateAgreement - Creates Agreement from selected Proposal. Initiates the Agreement handshake phase.  Formulates an Agreement artifact from the Proposal indicated by the received Proposal Id. Created Agreement is in &#x60;Proposal&#x60; state.  The Approval Expiry Date is added to Agreement artifact and implies the effective timeout on the whole Agreement Confirmation sequence.  A successful call to &#x60;createAgreement&#x60; shall immediately be followed by a &#x60;confirmAgreement&#x60; and &#x60;waitForApproval&#x60; call in order to listen for responses from the Provider.  **Note**: Moves given Proposal to &#x60;Approved&#x60; state. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementProposal"></param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<Golem.Common.Client.Client.ApiResponse<string>> CreateAgreementAsyncWithHttpInfo (AgreementProposal agreementProposal, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'agreementProposal' is set
            if (agreementProposal == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'agreementProposal' when calling RequestorApi->CreateAgreement");


            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };
            
            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);
            
            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);
            
            localVarRequestOptions.Data = agreementProposal;

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<string>("/agreements", localVarRequestOptions, this.Configuration, cancellationToken);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateAgreement", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// GetAgreement - Fetches agreement with given agreement id. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <returns>Agreement</returns>
        public Agreement GetAgreement (string agreementId)
        {
             Golem.Common.Client.Client.ApiResponse<Agreement> localVarResponse = GetAgreementWithHttpInfo(agreementId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// GetAgreement - Fetches agreement with given agreement id. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <returns>ApiResponse of Agreement</returns>
        public Golem.Common.Client.Client.ApiResponse< Agreement > GetAgreementWithHttpInfo (string agreementId)
        {
            // verify the required parameter 'agreementId' is set
            if (agreementId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'agreementId' when calling RequestorApi->GetAgreement");

            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Golem.Common.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Golem.Common.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (agreementId != null)
                localVarRequestOptions.PathParameters.Add("agreementId", Golem.Common.Client.Client.ClientUtils.ParameterToString(agreementId)); // path parameter

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get< Agreement >("/agreements/{agreementId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetAgreement", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// GetAgreement - Fetches agreement with given agreement id. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <returns>Task of Agreement</returns>
        public async System.Threading.Tasks.Task<Agreement> GetAgreementAsync (string agreementId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
             Golem.Common.Client.Client.ApiResponse<Agreement> localVarResponse = await GetAgreementAsyncWithHttpInfo(agreementId, cancellationToken);
             return localVarResponse.Data;

        }

        /// <summary>
        /// GetAgreement - Fetches agreement with given agreement id. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <returns>Task of ApiResponse (Agreement)</returns>
        public async System.Threading.Tasks.Task<Golem.Common.Client.Client.ApiResponse<Agreement>> GetAgreementAsyncWithHttpInfo (string agreementId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'agreementId' is set
            if (agreementId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'agreementId' when calling RequestorApi->GetAgreement");


            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };
            
            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);
            
            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);
            
            if (agreementId != null)
                localVarRequestOptions.PathParameters.Add("agreementId", Golem.Common.Client.Client.ClientUtils.ParameterToString(agreementId)); // path parameter

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<Agreement>("/agreements/{agreementId}", localVarRequestOptions, this.Configuration, cancellationToken);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetAgreement", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// GetDemands - Fetches all active Demands which have been published by the Requestor. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>List&lt;Demand&gt;</returns>
        public List<Demand> GetDemands ()
        {
             Golem.Common.Client.Client.ApiResponse<List<Demand>> localVarResponse = GetDemandsWithHttpInfo();
             return localVarResponse.Data;
        }

        /// <summary>
        /// GetDemands - Fetches all active Demands which have been published by the Requestor. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of List&lt;Demand&gt;</returns>
        public Golem.Common.Client.Client.ApiResponse< List<Demand> > GetDemandsWithHttpInfo ()
        {
            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Golem.Common.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Golem.Common.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);


            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get< List<Demand> >("/demands", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetDemands", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// GetDemands - Fetches all active Demands which have been published by the Requestor. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of List&lt;Demand&gt;</returns>
        public async System.Threading.Tasks.Task<List<Demand>> GetDemandsAsync (System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
             Golem.Common.Client.Client.ApiResponse<List<Demand>> localVarResponse = await GetDemandsAsyncWithHttpInfo(cancellationToken);
             return localVarResponse.Data;

        }

        /// <summary>
        /// GetDemands - Fetches all active Demands which have been published by the Requestor. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse (List&lt;Demand&gt;)</returns>
        public async System.Threading.Tasks.Task<Golem.Common.Client.Client.ApiResponse<List<Demand>>> GetDemandsAsyncWithHttpInfo (System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };
            
            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);
            
            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);
            

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<Demand>>("/demands", localVarRequestOptions, this.Configuration, cancellationToken);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetDemands", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// GetProposalOffer - Fetches Proposal (Offer) with given id. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <returns>Proposal</returns>
        public Proposal GetProposalOffer (string subscriptionId, string proposalId)
        {
             Golem.Common.Client.Client.ApiResponse<Proposal> localVarResponse = GetProposalOfferWithHttpInfo(subscriptionId, proposalId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// GetProposalOffer - Fetches Proposal (Offer) with given id. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <returns>ApiResponse of Proposal</returns>
        public Golem.Common.Client.Client.ApiResponse< Proposal > GetProposalOfferWithHttpInfo (string subscriptionId, string proposalId)
        {
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'subscriptionId' when calling RequestorApi->GetProposalOffer");

            // verify the required parameter 'proposalId' is set
            if (proposalId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'proposalId' when calling RequestorApi->GetProposalOffer");

            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Golem.Common.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Golem.Common.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (subscriptionId != null)
                localVarRequestOptions.PathParameters.Add("subscriptionId", Golem.Common.Client.Client.ClientUtils.ParameterToString(subscriptionId)); // path parameter
            if (proposalId != null)
                localVarRequestOptions.PathParameters.Add("proposalId", Golem.Common.Client.Client.ClientUtils.ParameterToString(proposalId)); // path parameter

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get< Proposal >("/demands/{subscriptionId}/proposals/{proposalId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetProposalOffer", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// GetProposalOffer - Fetches Proposal (Offer) with given id. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <returns>Task of Proposal</returns>
        public async System.Threading.Tasks.Task<Proposal> GetProposalOfferAsync (string subscriptionId, string proposalId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
             Golem.Common.Client.Client.ApiResponse<Proposal> localVarResponse = await GetProposalOfferAsyncWithHttpInfo(subscriptionId, proposalId, cancellationToken);
             return localVarResponse.Data;

        }

        /// <summary>
        /// GetProposalOffer - Fetches Proposal (Offer) with given id. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <returns>Task of ApiResponse (Proposal)</returns>
        public async System.Threading.Tasks.Task<Golem.Common.Client.Client.ApiResponse<Proposal>> GetProposalOfferAsyncWithHttpInfo (string subscriptionId, string proposalId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'subscriptionId' when calling RequestorApi->GetProposalOffer");

            // verify the required parameter 'proposalId' is set
            if (proposalId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'proposalId' when calling RequestorApi->GetProposalOffer");


            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };
            
            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);
            
            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);
            
            if (subscriptionId != null)
                localVarRequestOptions.PathParameters.Add("subscriptionId", Golem.Common.Client.Client.ClientUtils.ParameterToString(subscriptionId)); // path parameter
            if (proposalId != null)
                localVarRequestOptions.PathParameters.Add("proposalId", Golem.Common.Client.Client.ClientUtils.ParameterToString(proposalId)); // path parameter

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<Proposal>("/demands/{subscriptionId}/proposals/{proposalId}", localVarRequestOptions, this.Configuration, cancellationToken);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetProposalOffer", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// QueryReplyDemands - Handles dynamic property query. Sends a response to a received property value query.  The Market Matching Mechanism, when resolving the match relation for the specific Demand-Offer pair, is to detect the “dynamic” properties required (via constraints) by the other side. At this point, it is able to query the issuing node for those properties and submit the other side’s requested properties as the context of the query.  **Note**: The property query responses may be submitted in “chunks”, ie. the responder may choose to resolve ‘quick’/lightweight’ properties faster and provide response sooner, while still working on more time-consuming properties in the background. Therefore the response contains both the resolved properties, as well as list of properties which responder knows still require resolution.  **Note**: This method must be implemented for Market API Capability Level 2. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="queryId"></param>
        /// <param name="body"></param>
        /// <returns></returns>
        public void QueryReplyDemands (string subscriptionId, string queryId, Object body)
        {
             QueryReplyDemandsWithHttpInfo(subscriptionId, queryId, body);
        }

        /// <summary>
        /// QueryReplyDemands - Handles dynamic property query. Sends a response to a received property value query.  The Market Matching Mechanism, when resolving the match relation for the specific Demand-Offer pair, is to detect the “dynamic” properties required (via constraints) by the other side. At this point, it is able to query the issuing node for those properties and submit the other side’s requested properties as the context of the query.  **Note**: The property query responses may be submitted in “chunks”, ie. the responder may choose to resolve ‘quick’/lightweight’ properties faster and provide response sooner, while still working on more time-consuming properties in the background. Therefore the response contains both the resolved properties, as well as list of properties which responder knows still require resolution.  **Note**: This method must be implemented for Market API Capability Level 2. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="queryId"></param>
        /// <param name="body"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Golem.Common.Client.Client.ApiResponse<Object> QueryReplyDemandsWithHttpInfo (string subscriptionId, string queryId, Object body)
        {
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'subscriptionId' when calling RequestorApi->QueryReplyDemands");

            // verify the required parameter 'queryId' is set
            if (queryId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'queryId' when calling RequestorApi->QueryReplyDemands");

            // verify the required parameter 'body' is set
            if (body == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'body' when calling RequestorApi->QueryReplyDemands");

            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Golem.Common.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Golem.Common.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (subscriptionId != null)
                localVarRequestOptions.PathParameters.Add("subscriptionId", Golem.Common.Client.Client.ClientUtils.ParameterToString(subscriptionId)); // path parameter
            if (queryId != null)
                localVarRequestOptions.PathParameters.Add("queryId", Golem.Common.Client.Client.ClientUtils.ParameterToString(queryId)); // path parameter
            localVarRequestOptions.Data = body;

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/demands/{subscriptionId}/propertyQuery/{queryId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("QueryReplyDemands", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// QueryReplyDemands - Handles dynamic property query. Sends a response to a received property value query.  The Market Matching Mechanism, when resolving the match relation for the specific Demand-Offer pair, is to detect the “dynamic” properties required (via constraints) by the other side. At this point, it is able to query the issuing node for those properties and submit the other side’s requested properties as the context of the query.  **Note**: The property query responses may be submitted in “chunks”, ie. the responder may choose to resolve ‘quick’/lightweight’ properties faster and provide response sooner, while still working on more time-consuming properties in the background. Therefore the response contains both the resolved properties, as well as list of properties which responder knows still require resolution.  **Note**: This method must be implemented for Market API Capability Level 2. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="queryId"></param>
        /// <param name="body"></param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task QueryReplyDemandsAsync (string subscriptionId, string queryId, Object body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
             await QueryReplyDemandsAsyncWithHttpInfo(subscriptionId, queryId, body, cancellationToken);

        }

        /// <summary>
        /// QueryReplyDemands - Handles dynamic property query. Sends a response to a received property value query.  The Market Matching Mechanism, when resolving the match relation for the specific Demand-Offer pair, is to detect the “dynamic” properties required (via constraints) by the other side. At this point, it is able to query the issuing node for those properties and submit the other side’s requested properties as the context of the query.  **Note**: The property query responses may be submitted in “chunks”, ie. the responder may choose to resolve ‘quick’/lightweight’ properties faster and provide response sooner, while still working on more time-consuming properties in the background. Therefore the response contains both the resolved properties, as well as list of properties which responder knows still require resolution.  **Note**: This method must be implemented for Market API Capability Level 2. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="queryId"></param>
        /// <param name="body"></param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Golem.Common.Client.Client.ApiResponse<Object>> QueryReplyDemandsAsyncWithHttpInfo (string subscriptionId, string queryId, Object body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'subscriptionId' when calling RequestorApi->QueryReplyDemands");

            // verify the required parameter 'queryId' is set
            if (queryId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'queryId' when calling RequestorApi->QueryReplyDemands");

            // verify the required parameter 'body' is set
            if (body == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'body' when calling RequestorApi->QueryReplyDemands");


            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };
            
            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);
            
            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);
            
            if (subscriptionId != null)
                localVarRequestOptions.PathParameters.Add("subscriptionId", Golem.Common.Client.Client.ClientUtils.ParameterToString(subscriptionId)); // path parameter
            if (queryId != null)
                localVarRequestOptions.PathParameters.Add("queryId", Golem.Common.Client.Client.ClientUtils.ParameterToString(queryId)); // path parameter
            localVarRequestOptions.Data = body;

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/demands/{subscriptionId}/propertyQuery/{queryId}", localVarRequestOptions, this.Configuration, cancellationToken);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("QueryReplyDemands", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// RejectProposalOffer - Rejects Proposal (Offer). Effectively ends a Negotiation chain - it explicitly indicates that the sender will not create another counter-Proposal. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns></returns>
        public void RejectProposalOffer (string subscriptionId, string proposalId, Reason reason = default(Reason))
        {
             RejectProposalOfferWithHttpInfo(subscriptionId, proposalId, reason);
        }

        /// <summary>
        /// RejectProposalOffer - Rejects Proposal (Offer). Effectively ends a Negotiation chain - it explicitly indicates that the sender will not create another counter-Proposal. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Golem.Common.Client.Client.ApiResponse<Object> RejectProposalOfferWithHttpInfo (string subscriptionId, string proposalId, Reason reason = default(Reason))
        {
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'subscriptionId' when calling RequestorApi->RejectProposalOffer");

            // verify the required parameter 'proposalId' is set
            if (proposalId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'proposalId' when calling RequestorApi->RejectProposalOffer");

            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Golem.Common.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Golem.Common.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (subscriptionId != null)
                localVarRequestOptions.PathParameters.Add("subscriptionId", Golem.Common.Client.Client.ClientUtils.ParameterToString(subscriptionId)); // path parameter
            if (proposalId != null)
                localVarRequestOptions.PathParameters.Add("proposalId", Golem.Common.Client.Client.ClientUtils.ParameterToString(proposalId)); // path parameter
            localVarRequestOptions.Data = reason;

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/demands/{subscriptionId}/proposals/{proposalId}/reject", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RejectProposalOffer", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// RejectProposalOffer - Rejects Proposal (Offer). Effectively ends a Negotiation chain - it explicitly indicates that the sender will not create another counter-Proposal. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RejectProposalOfferAsync (string subscriptionId, string proposalId, Reason reason = default(Reason), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
             await RejectProposalOfferAsyncWithHttpInfo(subscriptionId, proposalId, reason, cancellationToken);

        }

        /// <summary>
        /// RejectProposalOffer - Rejects Proposal (Offer). Effectively ends a Negotiation chain - it explicitly indicates that the sender will not create another counter-Proposal. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Golem.Common.Client.Client.ApiResponse<Object>> RejectProposalOfferAsyncWithHttpInfo (string subscriptionId, string proposalId, Reason reason = default(Reason), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'subscriptionId' when calling RequestorApi->RejectProposalOffer");

            // verify the required parameter 'proposalId' is set
            if (proposalId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'proposalId' when calling RequestorApi->RejectProposalOffer");


            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };
            
            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);
            
            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);
            
            if (subscriptionId != null)
                localVarRequestOptions.PathParameters.Add("subscriptionId", Golem.Common.Client.Client.ClientUtils.ParameterToString(subscriptionId)); // path parameter
            if (proposalId != null)
                localVarRequestOptions.PathParameters.Add("proposalId", Golem.Common.Client.Client.ClientUtils.ParameterToString(proposalId)); // path parameter
            localVarRequestOptions.Data = reason;

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/demands/{subscriptionId}/proposals/{proposalId}/reject", localVarRequestOptions, this.Configuration, cancellationToken);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RejectProposalOffer", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// SubscribeDemand - Publishes Requestor capabilities via Demand. Demand object can be considered an \&quot;open\&quot; or public Demand, as it is not directed at a specific Provider, but rather is sent to the market so that the matching mechanism implementation can associate relevant Offers.  **Note**: it is an \&quot;atomic\&quot; operation, ie. as soon as Subscription is placed, the Demand is published on the market. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="demandOfferBase"></param>
        /// <returns>string</returns>
        public string SubscribeDemand (DemandOfferBase demandOfferBase)
        {
             Golem.Common.Client.Client.ApiResponse<string> localVarResponse = SubscribeDemandWithHttpInfo(demandOfferBase);
             return localVarResponse.Data;
        }

        /// <summary>
        /// SubscribeDemand - Publishes Requestor capabilities via Demand. Demand object can be considered an \&quot;open\&quot; or public Demand, as it is not directed at a specific Provider, but rather is sent to the market so that the matching mechanism implementation can associate relevant Offers.  **Note**: it is an \&quot;atomic\&quot; operation, ie. as soon as Subscription is placed, the Demand is published on the market. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="demandOfferBase"></param>
        /// <returns>ApiResponse of string</returns>
        public Golem.Common.Client.Client.ApiResponse< string > SubscribeDemandWithHttpInfo (DemandOfferBase demandOfferBase)
        {
            // verify the required parameter 'demandOfferBase' is set
            if (demandOfferBase == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'demandOfferBase' when calling RequestorApi->SubscribeDemand");

            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Golem.Common.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Golem.Common.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = demandOfferBase;

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post< string >("/demands", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SubscribeDemand", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// SubscribeDemand - Publishes Requestor capabilities via Demand. Demand object can be considered an \&quot;open\&quot; or public Demand, as it is not directed at a specific Provider, but rather is sent to the market so that the matching mechanism implementation can associate relevant Offers.  **Note**: it is an \&quot;atomic\&quot; operation, ie. as soon as Subscription is placed, the Demand is published on the market. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="demandOfferBase"></param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> SubscribeDemandAsync (DemandOfferBase demandOfferBase, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
             Golem.Common.Client.Client.ApiResponse<string> localVarResponse = await SubscribeDemandAsyncWithHttpInfo(demandOfferBase, cancellationToken);
             return localVarResponse.Data;

        }

        /// <summary>
        /// SubscribeDemand - Publishes Requestor capabilities via Demand. Demand object can be considered an \&quot;open\&quot; or public Demand, as it is not directed at a specific Provider, but rather is sent to the market so that the matching mechanism implementation can associate relevant Offers.  **Note**: it is an \&quot;atomic\&quot; operation, ie. as soon as Subscription is placed, the Demand is published on the market. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="demandOfferBase"></param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<Golem.Common.Client.Client.ApiResponse<string>> SubscribeDemandAsyncWithHttpInfo (DemandOfferBase demandOfferBase, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'demandOfferBase' is set
            if (demandOfferBase == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'demandOfferBase' when calling RequestorApi->SubscribeDemand");


            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };
            
            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);
            
            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);
            
            localVarRequestOptions.Data = demandOfferBase;

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<string>("/demands", localVarRequestOptions, this.Configuration, cancellationToken);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SubscribeDemand", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// TerminateAgreement - Terminates approved Agreement. Method to finish/close the Agreement while in &#x60;Approved&#x60; state.  The other party gets notified about calling party decision to terminate a \&quot;running\&quot; agreement.  **Note**: Can be invoked at any time after Agreement was approved by both sides.  **Note**: Financial and reputational consequences are not defined by this specification. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns></returns>
        public void TerminateAgreement (string agreementId, Dictionary<string, Object> requestBody = default(Dictionary<string, Object>))
        {
             TerminateAgreementWithHttpInfo(agreementId, requestBody);
        }

        /// <summary>
        /// TerminateAgreement - Terminates approved Agreement. Method to finish/close the Agreement while in &#x60;Approved&#x60; state.  The other party gets notified about calling party decision to terminate a \&quot;running\&quot; agreement.  **Note**: Can be invoked at any time after Agreement was approved by both sides.  **Note**: Financial and reputational consequences are not defined by this specification. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Golem.Common.Client.Client.ApiResponse<Object> TerminateAgreementWithHttpInfo (string agreementId, Dictionary<string, Object> requestBody = default(Dictionary<string, Object>))
        {
            // verify the required parameter 'agreementId' is set
            if (agreementId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'agreementId' when calling RequestorApi->TerminateAgreement");

            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Golem.Common.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Golem.Common.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (agreementId != null)
                localVarRequestOptions.PathParameters.Add("agreementId", Golem.Common.Client.Client.ClientUtils.ParameterToString(agreementId)); // path parameter
            localVarRequestOptions.Data = requestBody;

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/agreements/{agreementId}/terminate", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("TerminateAgreement", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// TerminateAgreement - Terminates approved Agreement. Method to finish/close the Agreement while in &#x60;Approved&#x60; state.  The other party gets notified about calling party decision to terminate a \&quot;running\&quot; agreement.  **Note**: Can be invoked at any time after Agreement was approved by both sides.  **Note**: Financial and reputational consequences are not defined by this specification. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task TerminateAgreementAsync (string agreementId, Dictionary<string, Object> requestBody = default(Dictionary<string, Object>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
             await TerminateAgreementAsyncWithHttpInfo(agreementId, requestBody, cancellationToken);

        }

        /// <summary>
        /// TerminateAgreement - Terminates approved Agreement. Method to finish/close the Agreement while in &#x60;Approved&#x60; state.  The other party gets notified about calling party decision to terminate a \&quot;running\&quot; agreement.  **Note**: Can be invoked at any time after Agreement was approved by both sides.  **Note**: Financial and reputational consequences are not defined by this specification. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Golem.Common.Client.Client.ApiResponse<Object>> TerminateAgreementAsyncWithHttpInfo (string agreementId, Dictionary<string, Object> requestBody = default(Dictionary<string, Object>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'agreementId' is set
            if (agreementId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'agreementId' when calling RequestorApi->TerminateAgreement");


            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };
            
            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);
            
            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);
            
            if (agreementId != null)
                localVarRequestOptions.PathParameters.Add("agreementId", Golem.Common.Client.Client.ClientUtils.ParameterToString(agreementId)); // path parameter
            localVarRequestOptions.Data = requestBody;

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/agreements/{agreementId}/terminate", localVarRequestOptions, this.Configuration, cancellationToken);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("TerminateAgreement", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// UnsubscribeDemand - Stop subscription for previously published Demand. Stop receiving Proposals.  **Note**: this will terminate all pending &#x60;collectOffers&#x60; calls on this subscription. This implies, that client code should not &#x60;unsubscribeDemand&#x60; before it has received all expected/useful inputs from &#x60;collectOffers&#x60;. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <returns></returns>
        public void UnsubscribeDemand (string subscriptionId)
        {
             UnsubscribeDemandWithHttpInfo(subscriptionId);
        }

        /// <summary>
        /// UnsubscribeDemand - Stop subscription for previously published Demand. Stop receiving Proposals.  **Note**: this will terminate all pending &#x60;collectOffers&#x60; calls on this subscription. This implies, that client code should not &#x60;unsubscribeDemand&#x60; before it has received all expected/useful inputs from &#x60;collectOffers&#x60;. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Golem.Common.Client.Client.ApiResponse<Object> UnsubscribeDemandWithHttpInfo (string subscriptionId)
        {
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'subscriptionId' when calling RequestorApi->UnsubscribeDemand");

            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Golem.Common.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Golem.Common.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (subscriptionId != null)
                localVarRequestOptions.PathParameters.Add("subscriptionId", Golem.Common.Client.Client.ClientUtils.ParameterToString(subscriptionId)); // path parameter

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/demands/{subscriptionId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UnsubscribeDemand", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// UnsubscribeDemand - Stop subscription for previously published Demand. Stop receiving Proposals.  **Note**: this will terminate all pending &#x60;collectOffers&#x60; calls on this subscription. This implies, that client code should not &#x60;unsubscribeDemand&#x60; before it has received all expected/useful inputs from &#x60;collectOffers&#x60;. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task UnsubscribeDemandAsync (string subscriptionId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
             await UnsubscribeDemandAsyncWithHttpInfo(subscriptionId, cancellationToken);

        }

        /// <summary>
        /// UnsubscribeDemand - Stop subscription for previously published Demand. Stop receiving Proposals.  **Note**: this will terminate all pending &#x60;collectOffers&#x60; calls on this subscription. This implies, that client code should not &#x60;unsubscribeDemand&#x60; before it has received all expected/useful inputs from &#x60;collectOffers&#x60;. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Golem.Common.Client.Client.ApiResponse<Object>> UnsubscribeDemandAsyncWithHttpInfo (string subscriptionId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'subscriptionId' when calling RequestorApi->UnsubscribeDemand");


            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };
            
            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);
            
            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);
            
            if (subscriptionId != null)
                localVarRequestOptions.PathParameters.Add("subscriptionId", Golem.Common.Client.Client.ClientUtils.ParameterToString(subscriptionId)); // path parameter

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/demands/{subscriptionId}", localVarRequestOptions, this.Configuration, cancellationToken);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UnsubscribeDemand", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// WaitForApproval - Waits for Agreement approval by the Provider. This is a blocking operation. The call may be aborted by Requestor caller code. After the call is aborted or timed out, another &#x60;waitForApproval&#x60; call can be raised on the same Agreement Id. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="timeout">Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party&#39;s response indefinitely)  (optional, default to 5.0F)</param>
        /// <returns></returns>
        public void WaitForApproval (string agreementId, float? timeout = default(float?))
        {
             WaitForApprovalWithHttpInfo(agreementId, timeout);
        }

        /// <summary>
        /// WaitForApproval - Waits for Agreement approval by the Provider. This is a blocking operation. The call may be aborted by Requestor caller code. After the call is aborted or timed out, another &#x60;waitForApproval&#x60; call can be raised on the same Agreement Id. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="timeout">Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party&#39;s response indefinitely)  (optional, default to 5.0F)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Golem.Common.Client.Client.ApiResponse<Object> WaitForApprovalWithHttpInfo (string agreementId, float? timeout = default(float?))
        {
            // verify the required parameter 'agreementId' is set
            if (agreementId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'agreementId' when calling RequestorApi->WaitForApproval");

            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Golem.Common.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Golem.Common.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (agreementId != null)
                localVarRequestOptions.PathParameters.Add("agreementId", Golem.Common.Client.Client.ClientUtils.ParameterToString(agreementId)); // path parameter
            if (timeout != null)
            {
                localVarRequestOptions.QueryParameters.Add(Golem.Common.Client.Client.ClientUtils.ParameterToMultiMap("", "timeout", timeout));
            }

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/agreements/{agreementId}/wait", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("WaitForApproval", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// WaitForApproval - Waits for Agreement approval by the Provider. This is a blocking operation. The call may be aborted by Requestor caller code. After the call is aborted or timed out, another &#x60;waitForApproval&#x60; call can be raised on the same Agreement Id. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="timeout">Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party&#39;s response indefinitely)  (optional, default to 5.0F)</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task WaitForApprovalAsync (string agreementId, float? timeout = default(float?), CancellationToken token = default(CancellationToken))
        {
             await WaitForApprovalAsyncWithHttpInfo(agreementId, timeout, token);

        }

        /// <summary>
        /// WaitForApproval - Waits for Agreement approval by the Provider. This is a blocking operation. The call may be aborted by Requestor caller code. After the call is aborted or timed out, another &#x60;waitForApproval&#x60; call can be raised on the same Agreement Id. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="timeout">Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party&#39;s response indefinitely)  (optional, default to 5.0F)</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Golem.Common.Client.Client.ApiResponse<Object>> WaitForApprovalAsyncWithHttpInfo (string agreementId, float? timeout = default(float?), CancellationToken token = default(CancellationToken))
        {
            // verify the required parameter 'agreementId' is set
            if (agreementId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'agreementId' when calling RequestorApi->WaitForApproval");


            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };
            
            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);
            
            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);
            
            if (agreementId != null)
                localVarRequestOptions.PathParameters.Add("agreementId", Golem.Common.Client.Client.ClientUtils.ParameterToString(agreementId)); // path parameter
            if (timeout != null)
            {
                localVarRequestOptions.QueryParameters.Add(Golem.Common.Client.Client.ClientUtils.ParameterToMultiMap("", "timeout", timeout));
            }

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/agreements/{agreementId}/wait", localVarRequestOptions, this.Configuration, token);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("WaitForApproval", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

    }
}
