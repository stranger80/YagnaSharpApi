/* 
 * Yagna Market API
 *
 *  ## Yagna Market The Yagna Market is a core component of the Yagna Network, which enables computational Offers and Demands circulation. The Market is open for all entities willing to buy computations (Demands) or monetize computational resources (Offers). ## Yagna Market API The Yagna Market API is the entry to the Yagna Market through which Requestors and Providers can publish their Demands and Offers respectively, find matching counterparty, conduct negotiations and make an agreement.  This version of Market API conforms with capability level 1 of the <a href=\"https://docs.google.com/document/d/1Zny_vfgWV-hcsKS7P-Kdr3Fb0dwfl-6T_cYKVQ9mkNg\"> Market API specification</a>.  Market API contains two roles: Requestors and Providers which are symmetrical most of the time (excluding agreement phase). 
 *
 * The version of the OpenAPI document: 1.6.1
 * 
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using Golem.Common.Client.Client;
using Golem.MarketApi.Client.Model;

namespace Golem.MarketApi.Client.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IProviderApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// ApproveAgreement - Approves Agreement proposed by the Reqestor.
        /// </summary>
        /// <remarks>
        /// This is a blocking operation. The call may be aborted by Provider caller code. After the call is aborted or timed out, another &#x60;approveAgreement&#x60; call can be raised on the same &#x60;agreementId&#x60;.  **Note**: It is expected from the Provider node implementation to “ring-fence” the resources required to fulfill the Agreement before the ApproveAgreement is sent. However, the resources should not be fully committed until &#x60;Approved&#x60; response is received from the &#x60;approveAgreement&#x60; call.  **Note**: Mutually exclusive with &#x60;rejectAgreement&#x60;. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="appSessionId">A correlation/session identifier used for querying events related to an action where this appSessionId has been specified (optional)</param>
        /// <param name="timeout">Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party&#39;s response indefinitely)  (optional, default to 5.0F)</param>
        /// <returns></returns>
        void ApproveAgreement (string agreementId, string appSessionId = default(string), float? timeout = default(float?));

        /// <summary>
        /// ApproveAgreement - Approves Agreement proposed by the Reqestor.
        /// </summary>
        /// <remarks>
        /// This is a blocking operation. The call may be aborted by Provider caller code. After the call is aborted or timed out, another &#x60;approveAgreement&#x60; call can be raised on the same &#x60;agreementId&#x60;.  **Note**: It is expected from the Provider node implementation to “ring-fence” the resources required to fulfill the Agreement before the ApproveAgreement is sent. However, the resources should not be fully committed until &#x60;Approved&#x60; response is received from the &#x60;approveAgreement&#x60; call.  **Note**: Mutually exclusive with &#x60;rejectAgreement&#x60;. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="appSessionId">A correlation/session identifier used for querying events related to an action where this appSessionId has been specified (optional)</param>
        /// <param name="timeout">Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party&#39;s response indefinitely)  (optional, default to 5.0F)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ApproveAgreementWithHttpInfo (string agreementId, string appSessionId = default(string), float? timeout = default(float?));
        /// <summary>
        /// CollectAgreementEvents - Collects events related to an Agreement.
        /// </summary>
        /// <remarks>
        /// This is a blocking operation. It will not return until there is at least one new event. All events are appearing on both sides equally.  Returns Agreement related events: * &#x60;AgreementApprovedEvent&#x60; - Indicates that the Agreement has been approved   by the Provider.   - The Provider is now ready to accept a request to start an Activity     as described in the negotiated agreement.   - The Providers’s corresponding &#x60;approveAgreement&#x60; call returns &#x60;Approved&#x60;     after this event is emitted.  * &#x60;AgreementRejectedEvent&#x60; - Indicates that the Provider has called   &#x60;rejectAgreement&#x60;, which effectively stops the Agreement handshake.   The Requestor may attempt to return to the Negotiation phase by sending   a new Proposal.  * &#x60;AgreementCancelledEvent&#x60; - Indicates that the Requestor has called   &#x60;cancelAgreement&#x60;, which effectively stops the Agreement handshake.  * &#x60;AgreementTerminatedEvent&#x60; - Indicates that the Agreement has been   terminated by specified party (contains signature). 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="timeout">Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)  (optional, default to 5.0F)</param>
        /// <param name="afterTimestamp">Apply only to records created later than the specified timestamp (optional)</param>
        /// <param name="maxEvents">Maximum number of events that server should return at once.  (optional, default to 10)</param>
        /// <param name="appSessionId">A correlation/session identifier used for querying events related to an action where this appSessionId has been specified (optional)</param>
        /// <returns>List&lt;AgreementEvent&gt;</returns>
        List<AgreementEvent> CollectAgreementEvents (float? timeout = default(float?), DateTime? afterTimestamp = default(DateTime?), int? maxEvents = default(int?), string appSessionId = default(string));

        /// <summary>
        /// CollectAgreementEvents - Collects events related to an Agreement.
        /// </summary>
        /// <remarks>
        /// This is a blocking operation. It will not return until there is at least one new event. All events are appearing on both sides equally.  Returns Agreement related events: * &#x60;AgreementApprovedEvent&#x60; - Indicates that the Agreement has been approved   by the Provider.   - The Provider is now ready to accept a request to start an Activity     as described in the negotiated agreement.   - The Providers’s corresponding &#x60;approveAgreement&#x60; call returns &#x60;Approved&#x60;     after this event is emitted.  * &#x60;AgreementRejectedEvent&#x60; - Indicates that the Provider has called   &#x60;rejectAgreement&#x60;, which effectively stops the Agreement handshake.   The Requestor may attempt to return to the Negotiation phase by sending   a new Proposal.  * &#x60;AgreementCancelledEvent&#x60; - Indicates that the Requestor has called   &#x60;cancelAgreement&#x60;, which effectively stops the Agreement handshake.  * &#x60;AgreementTerminatedEvent&#x60; - Indicates that the Agreement has been   terminated by specified party (contains signature). 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="timeout">Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)  (optional, default to 5.0F)</param>
        /// <param name="afterTimestamp">Apply only to records created later than the specified timestamp (optional)</param>
        /// <param name="maxEvents">Maximum number of events that server should return at once.  (optional, default to 10)</param>
        /// <param name="appSessionId">A correlation/session identifier used for querying events related to an action where this appSessionId has been specified (optional)</param>
        /// <returns>ApiResponse of List&lt;AgreementEvent&gt;</returns>
        ApiResponse<List<AgreementEvent>> CollectAgreementEventsWithHttpInfo (float? timeout = default(float?), DateTime? afterTimestamp = default(DateTime?), int? maxEvents = default(int?), string appSessionId = default(string));
        /// <summary>
        /// CollectDemands - Reads Market responses to published Offer.
        /// </summary>
        /// <remarks>
        /// This is a blocking operation. It will not return until there is at least one new event. Returns Proposal related events: * &#x60;ProposalEvent&#x60; - Indicates that there is new Demand Proposal for this Offer. * &#x60;ProposalRejectedEvent&#x60; - Indicates that the Requestor has rejected   our previous Proposal related to this Offer. This effectively ends a   Negotiation chain - it explicitly indicates that the sender will not   create another counter-Proposal.  * &#x60;AgreementEvent&#x60; - Indicates that the Requestor is accepting our   previous Proposal and ask for our approval of the Agreement.  * &#x60;PropertyQueryEvent&#x60; - not supported yet.  **Note**: When &#x60;collectDemands&#x60; is waiting, simultaneous call to &#x60;unsubscribeOffer&#x60; on the same &#x60;subscriptionId&#x60; should result in \&quot;Subscription does not exist\&quot; error returned from &#x60;collectDemands&#x60;.  **Note**: Specification requires this endpoint to support list of specific Proposal Ids to listen for messages related only to specific Proposals. This is not covered yet. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="timeout">Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)  (optional, default to 5.0F)</param>
        /// <param name="maxEvents">Maximum number of events that server should return at once.  (optional, default to 10)</param>
        /// <returns>List&lt;Event&gt;</returns>
        List<Event> CollectDemands (string subscriptionId, float? timeout = default(float?), int? maxEvents = default(int?));

        /// <summary>
        /// CollectDemands - Reads Market responses to published Offer.
        /// </summary>
        /// <remarks>
        /// This is a blocking operation. It will not return until there is at least one new event. Returns Proposal related events: * &#x60;ProposalEvent&#x60; - Indicates that there is new Demand Proposal for this Offer. * &#x60;ProposalRejectedEvent&#x60; - Indicates that the Requestor has rejected   our previous Proposal related to this Offer. This effectively ends a   Negotiation chain - it explicitly indicates that the sender will not   create another counter-Proposal.  * &#x60;AgreementEvent&#x60; - Indicates that the Requestor is accepting our   previous Proposal and ask for our approval of the Agreement.  * &#x60;PropertyQueryEvent&#x60; - not supported yet.  **Note**: When &#x60;collectDemands&#x60; is waiting, simultaneous call to &#x60;unsubscribeOffer&#x60; on the same &#x60;subscriptionId&#x60; should result in \&quot;Subscription does not exist\&quot; error returned from &#x60;collectDemands&#x60;.  **Note**: Specification requires this endpoint to support list of specific Proposal Ids to listen for messages related only to specific Proposals. This is not covered yet. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="timeout">Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)  (optional, default to 5.0F)</param>
        /// <param name="maxEvents">Maximum number of events that server should return at once.  (optional, default to 10)</param>
        /// <returns>ApiResponse of List&lt;Event&gt;</returns>
        ApiResponse<List<Event>> CollectDemandsWithHttpInfo (string subscriptionId, float? timeout = default(float?), int? maxEvents = default(int?));
        /// <summary>
        /// CounterProposalOffer - Responds with a bespoke Offer to received Demand.
        /// </summary>
        /// <remarks>
        /// Creates and sends a modified version of original Offer (a counter-proposal) adjusted to previously received Proposal (ie. Demand). Changes Proposal state to &#x60;Draft&#x60;. Returns created Proposal id. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <param name="demandOfferBase"></param>
        /// <returns>string</returns>
        string CounterProposalOffer (string subscriptionId, string proposalId, DemandOfferBase demandOfferBase);

        /// <summary>
        /// CounterProposalOffer - Responds with a bespoke Offer to received Demand.
        /// </summary>
        /// <remarks>
        /// Creates and sends a modified version of original Offer (a counter-proposal) adjusted to previously received Proposal (ie. Demand). Changes Proposal state to &#x60;Draft&#x60;. Returns created Proposal id. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <param name="demandOfferBase"></param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> CounterProposalOfferWithHttpInfo (string subscriptionId, string proposalId, DemandOfferBase demandOfferBase);
        /// <summary>
        /// GetAgreement - Fetches agreement with given agreement id.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <returns>Agreement</returns>
        Agreement GetAgreement (string agreementId);

        /// <summary>
        /// GetAgreement - Fetches agreement with given agreement id.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <returns>ApiResponse of Agreement</returns>
        ApiResponse<Agreement> GetAgreementWithHttpInfo (string agreementId);
        /// <summary>
        /// GetOffers - Fetches all active Offers which have been published by the Provider.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>List&lt;Offer&gt;</returns>
        List<Offer> GetOffers ();

        /// <summary>
        /// GetOffers - Fetches all active Offers which have been published by the Provider.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of List&lt;Offer&gt;</returns>
        ApiResponse<List<Offer>> GetOffersWithHttpInfo ();
        /// <summary>
        /// GetProposalDemand - Fetches Proposal (Demand) with given id.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <returns>Proposal</returns>
        Proposal GetProposalDemand (string subscriptionId, string proposalId);

        /// <summary>
        /// GetProposalDemand - Fetches Proposal (Demand) with given id.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <returns>ApiResponse of Proposal</returns>
        ApiResponse<Proposal> GetProposalDemandWithHttpInfo (string subscriptionId, string proposalId);
        /// <summary>
        /// QueryReplyOffers - Handles dynamic property query.
        /// </summary>
        /// <remarks>
        /// Sends a response to a received property value query.  The Market Matching Mechanism, when resolving the match relation for the specific Demand-Offer pair, is to detect the “dynamic” properties required (via constraints) by the other side. At this point, it is able to query the issuing node for those properties and submit the other side’s requested properties as the context of the query.  **Note**: The property query responses may be submitted in “chunks”, ie. the responder may choose to resolve ‘quick’/lightweight’ properties faster and provide response sooner, while still working on more time-consuming properties in the background. Therefore the response contains both the resolved properties, as well as list of properties which responder knows still require resolution.  **Note**: This method must be implemented for Market API Capability Level 2. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="queryId"></param>
        /// <param name="body"></param>
        /// <returns></returns>
        void QueryReplyOffers (string subscriptionId, string queryId, Object body);

        /// <summary>
        /// QueryReplyOffers - Handles dynamic property query.
        /// </summary>
        /// <remarks>
        /// Sends a response to a received property value query.  The Market Matching Mechanism, when resolving the match relation for the specific Demand-Offer pair, is to detect the “dynamic” properties required (via constraints) by the other side. At this point, it is able to query the issuing node for those properties and submit the other side’s requested properties as the context of the query.  **Note**: The property query responses may be submitted in “chunks”, ie. the responder may choose to resolve ‘quick’/lightweight’ properties faster and provide response sooner, while still working on more time-consuming properties in the background. Therefore the response contains both the resolved properties, as well as list of properties which responder knows still require resolution.  **Note**: This method must be implemented for Market API Capability Level 2. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="queryId"></param>
        /// <param name="body"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> QueryReplyOffersWithHttpInfo (string subscriptionId, string queryId, Object body);
        /// <summary>
        /// RejectAgreement - Rejects Agreement proposed by the Requestor.
        /// </summary>
        /// <remarks>
        /// The Requestor side is notified about the Provider’s decision to reject a negotiated agreement. This effectively stops the Agreement handshake.  **Note**: Mutually exclusive with &#x60;approveAgreement&#x60;. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns></returns>
        void RejectAgreement (string agreementId, Dictionary<string, Object> requestBody = default(Dictionary<string, Object>));

        /// <summary>
        /// RejectAgreement - Rejects Agreement proposed by the Requestor.
        /// </summary>
        /// <remarks>
        /// The Requestor side is notified about the Provider’s decision to reject a negotiated agreement. This effectively stops the Agreement handshake.  **Note**: Mutually exclusive with &#x60;approveAgreement&#x60;. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RejectAgreementWithHttpInfo (string agreementId, Dictionary<string, Object> requestBody = default(Dictionary<string, Object>));
        /// <summary>
        /// RejectProposalDemand - Rejects Proposal (Demand).
        /// </summary>
        /// <remarks>
        /// Effectively ends a Negotiation chain - it explicitly indicates that the sender will not create another counter-Proposal. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns></returns>
        void RejectProposalDemand (string subscriptionId, string proposalId, Dictionary<string, Object> requestBody = default(Dictionary<string, Object>));

        /// <summary>
        /// RejectProposalDemand - Rejects Proposal (Demand).
        /// </summary>
        /// <remarks>
        /// Effectively ends a Negotiation chain - it explicitly indicates that the sender will not create another counter-Proposal. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RejectProposalDemandWithHttpInfo (string subscriptionId, string proposalId, Dictionary<string, Object> requestBody = default(Dictionary<string, Object>));
        /// <summary>
        /// SubscribeOffer - Publishes Provider capabilities via Offer.
        /// </summary>
        /// <remarks>
        /// Offer object can be considered an \&quot;open\&quot; or public Offer, as it is not directed at a specific Requestor, but rather is sent to the market so that the matching mechanism implementation can associate relevant Demands.  **Note**: it is an \&quot;atomic\&quot; operation, ie. as soon as Subscription is placed, the Offer is published on the market. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="demandOfferBase"></param>
        /// <returns>string</returns>
        string SubscribeOffer (DemandOfferBase demandOfferBase);

        /// <summary>
        /// SubscribeOffer - Publishes Provider capabilities via Offer.
        /// </summary>
        /// <remarks>
        /// Offer object can be considered an \&quot;open\&quot; or public Offer, as it is not directed at a specific Requestor, but rather is sent to the market so that the matching mechanism implementation can associate relevant Demands.  **Note**: it is an \&quot;atomic\&quot; operation, ie. as soon as Subscription is placed, the Offer is published on the market. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="demandOfferBase"></param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> SubscribeOfferWithHttpInfo (DemandOfferBase demandOfferBase);
        /// <summary>
        /// TerminateAgreement - Terminates approved Agreement.
        /// </summary>
        /// <remarks>
        /// Method to finish/close the Agreement while in &#x60;Approved&#x60; state.  The other party gets notified about calling party decision to terminate a \&quot;running\&quot; agreement.  **Note**: Can be invoked at any time after Agreement was approved by both sides.  **Note**: Financial and reputational consequences are not defined by this specification. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns></returns>
        void TerminateAgreement (string agreementId, Dictionary<string, Object> requestBody = default(Dictionary<string, Object>));

        /// <summary>
        /// TerminateAgreement - Terminates approved Agreement.
        /// </summary>
        /// <remarks>
        /// Method to finish/close the Agreement while in &#x60;Approved&#x60; state.  The other party gets notified about calling party decision to terminate a \&quot;running\&quot; agreement.  **Note**: Can be invoked at any time after Agreement was approved by both sides.  **Note**: Financial and reputational consequences are not defined by this specification. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> TerminateAgreementWithHttpInfo (string agreementId, Dictionary<string, Object> requestBody = default(Dictionary<string, Object>));
        /// <summary>
        /// UnsubscribeOffer - Stop subscription for previously published Offer.
        /// </summary>
        /// <remarks>
        /// Stop receiving Proposals.  **Note**: this will terminate all pending &#x60;collectDemands&#x60; calls on this subscription. This implies, that client code should not &#x60;unsubscribeOffer&#x60; before it has received all expected/useful inputs from &#x60;collectDemands&#x60;. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <returns></returns>
        void UnsubscribeOffer (string subscriptionId);

        /// <summary>
        /// UnsubscribeOffer - Stop subscription for previously published Offer.
        /// </summary>
        /// <remarks>
        /// Stop receiving Proposals.  **Note**: this will terminate all pending &#x60;collectDemands&#x60; calls on this subscription. This implies, that client code should not &#x60;unsubscribeOffer&#x60; before it has received all expected/useful inputs from &#x60;collectDemands&#x60;. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UnsubscribeOfferWithHttpInfo (string subscriptionId);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IProviderApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// ApproveAgreement - Approves Agreement proposed by the Reqestor.
        /// </summary>
        /// <remarks>
        /// This is a blocking operation. The call may be aborted by Provider caller code. After the call is aborted or timed out, another &#x60;approveAgreement&#x60; call can be raised on the same &#x60;agreementId&#x60;.  **Note**: It is expected from the Provider node implementation to “ring-fence” the resources required to fulfill the Agreement before the ApproveAgreement is sent. However, the resources should not be fully committed until &#x60;Approved&#x60; response is received from the &#x60;approveAgreement&#x60; call.  **Note**: Mutually exclusive with &#x60;rejectAgreement&#x60;. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="appSessionId">A correlation/session identifier used for querying events related to an action where this appSessionId has been specified (optional)</param>
        /// <param name="timeout">Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party&#39;s response indefinitely)  (optional, default to 5.0F)</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task ApproveAgreementAsync (string agreementId, string appSessionId = default(string), float? timeout = default(float?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// ApproveAgreement - Approves Agreement proposed by the Reqestor.
        /// </summary>
        /// <remarks>
        /// This is a blocking operation. The call may be aborted by Provider caller code. After the call is aborted or timed out, another &#x60;approveAgreement&#x60; call can be raised on the same &#x60;agreementId&#x60;.  **Note**: It is expected from the Provider node implementation to “ring-fence” the resources required to fulfill the Agreement before the ApproveAgreement is sent. However, the resources should not be fully committed until &#x60;Approved&#x60; response is received from the &#x60;approveAgreement&#x60; call.  **Note**: Mutually exclusive with &#x60;rejectAgreement&#x60;. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="appSessionId">A correlation/session identifier used for querying events related to an action where this appSessionId has been specified (optional)</param>
        /// <param name="timeout">Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party&#39;s response indefinitely)  (optional, default to 5.0F)</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> ApproveAgreementAsyncWithHttpInfo (string agreementId, string appSessionId = default(string), float? timeout = default(float?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// CollectAgreementEvents - Collects events related to an Agreement.
        /// </summary>
        /// <remarks>
        /// This is a blocking operation. It will not return until there is at least one new event. All events are appearing on both sides equally.  Returns Agreement related events: * &#x60;AgreementApprovedEvent&#x60; - Indicates that the Agreement has been approved   by the Provider.   - The Provider is now ready to accept a request to start an Activity     as described in the negotiated agreement.   - The Providers’s corresponding &#x60;approveAgreement&#x60; call returns &#x60;Approved&#x60;     after this event is emitted.  * &#x60;AgreementRejectedEvent&#x60; - Indicates that the Provider has called   &#x60;rejectAgreement&#x60;, which effectively stops the Agreement handshake.   The Requestor may attempt to return to the Negotiation phase by sending   a new Proposal.  * &#x60;AgreementCancelledEvent&#x60; - Indicates that the Requestor has called   &#x60;cancelAgreement&#x60;, which effectively stops the Agreement handshake.  * &#x60;AgreementTerminatedEvent&#x60; - Indicates that the Agreement has been   terminated by specified party (contains signature). 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="timeout">Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)  (optional, default to 5.0F)</param>
        /// <param name="afterTimestamp">Apply only to records created later than the specified timestamp (optional)</param>
        /// <param name="maxEvents">Maximum number of events that server should return at once.  (optional, default to 10)</param>
        /// <param name="appSessionId">A correlation/session identifier used for querying events related to an action where this appSessionId has been specified (optional)</param>
        /// <returns>Task of List&lt;AgreementEvent&gt;</returns>
        System.Threading.Tasks.Task<List<AgreementEvent>> CollectAgreementEventsAsync (float? timeout = default(float?), DateTime? afterTimestamp = default(DateTime?), int? maxEvents = default(int?), string appSessionId = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// CollectAgreementEvents - Collects events related to an Agreement.
        /// </summary>
        /// <remarks>
        /// This is a blocking operation. It will not return until there is at least one new event. All events are appearing on both sides equally.  Returns Agreement related events: * &#x60;AgreementApprovedEvent&#x60; - Indicates that the Agreement has been approved   by the Provider.   - The Provider is now ready to accept a request to start an Activity     as described in the negotiated agreement.   - The Providers’s corresponding &#x60;approveAgreement&#x60; call returns &#x60;Approved&#x60;     after this event is emitted.  * &#x60;AgreementRejectedEvent&#x60; - Indicates that the Provider has called   &#x60;rejectAgreement&#x60;, which effectively stops the Agreement handshake.   The Requestor may attempt to return to the Negotiation phase by sending   a new Proposal.  * &#x60;AgreementCancelledEvent&#x60; - Indicates that the Requestor has called   &#x60;cancelAgreement&#x60;, which effectively stops the Agreement handshake.  * &#x60;AgreementTerminatedEvent&#x60; - Indicates that the Agreement has been   terminated by specified party (contains signature). 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="timeout">Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)  (optional, default to 5.0F)</param>
        /// <param name="afterTimestamp">Apply only to records created later than the specified timestamp (optional)</param>
        /// <param name="maxEvents">Maximum number of events that server should return at once.  (optional, default to 10)</param>
        /// <param name="appSessionId">A correlation/session identifier used for querying events related to an action where this appSessionId has been specified (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;AgreementEvent&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<AgreementEvent>>> CollectAgreementEventsAsyncWithHttpInfo (float? timeout = default(float?), DateTime? afterTimestamp = default(DateTime?), int? maxEvents = default(int?), string appSessionId = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// CollectDemands - Reads Market responses to published Offer.
        /// </summary>
        /// <remarks>
        /// This is a blocking operation. It will not return until there is at least one new event. Returns Proposal related events: * &#x60;ProposalEvent&#x60; - Indicates that there is new Demand Proposal for this Offer. * &#x60;ProposalRejectedEvent&#x60; - Indicates that the Requestor has rejected   our previous Proposal related to this Offer. This effectively ends a   Negotiation chain - it explicitly indicates that the sender will not   create another counter-Proposal.  * &#x60;AgreementEvent&#x60; - Indicates that the Requestor is accepting our   previous Proposal and ask for our approval of the Agreement.  * &#x60;PropertyQueryEvent&#x60; - not supported yet.  **Note**: When &#x60;collectDemands&#x60; is waiting, simultaneous call to &#x60;unsubscribeOffer&#x60; on the same &#x60;subscriptionId&#x60; should result in \&quot;Subscription does not exist\&quot; error returned from &#x60;collectDemands&#x60;.  **Note**: Specification requires this endpoint to support list of specific Proposal Ids to listen for messages related only to specific Proposals. This is not covered yet. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="timeout">Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)  (optional, default to 5.0F)</param>
        /// <param name="maxEvents">Maximum number of events that server should return at once.  (optional, default to 10)</param>
        /// <returns>Task of List&lt;Event&gt;</returns>
        System.Threading.Tasks.Task<List<Event>> CollectDemandsAsync (string subscriptionId, float? timeout = default(float?), int? maxEvents = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// CollectDemands - Reads Market responses to published Offer.
        /// </summary>
        /// <remarks>
        /// This is a blocking operation. It will not return until there is at least one new event. Returns Proposal related events: * &#x60;ProposalEvent&#x60; - Indicates that there is new Demand Proposal for this Offer. * &#x60;ProposalRejectedEvent&#x60; - Indicates that the Requestor has rejected   our previous Proposal related to this Offer. This effectively ends a   Negotiation chain - it explicitly indicates that the sender will not   create another counter-Proposal.  * &#x60;AgreementEvent&#x60; - Indicates that the Requestor is accepting our   previous Proposal and ask for our approval of the Agreement.  * &#x60;PropertyQueryEvent&#x60; - not supported yet.  **Note**: When &#x60;collectDemands&#x60; is waiting, simultaneous call to &#x60;unsubscribeOffer&#x60; on the same &#x60;subscriptionId&#x60; should result in \&quot;Subscription does not exist\&quot; error returned from &#x60;collectDemands&#x60;.  **Note**: Specification requires this endpoint to support list of specific Proposal Ids to listen for messages related only to specific Proposals. This is not covered yet. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="timeout">Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)  (optional, default to 5.0F)</param>
        /// <param name="maxEvents">Maximum number of events that server should return at once.  (optional, default to 10)</param>
        /// <returns>Task of ApiResponse (List&lt;Event&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<Event>>> CollectDemandsAsyncWithHttpInfo (string subscriptionId, float? timeout = default(float?), int? maxEvents = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// CounterProposalOffer - Responds with a bespoke Offer to received Demand.
        /// </summary>
        /// <remarks>
        /// Creates and sends a modified version of original Offer (a counter-proposal) adjusted to previously received Proposal (ie. Demand). Changes Proposal state to &#x60;Draft&#x60;. Returns created Proposal id. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <param name="demandOfferBase"></param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> CounterProposalOfferAsync (string subscriptionId, string proposalId, DemandOfferBase demandOfferBase, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// CounterProposalOffer - Responds with a bespoke Offer to received Demand.
        /// </summary>
        /// <remarks>
        /// Creates and sends a modified version of original Offer (a counter-proposal) adjusted to previously received Proposal (ie. Demand). Changes Proposal state to &#x60;Draft&#x60;. Returns created Proposal id. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <param name="demandOfferBase"></param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> CounterProposalOfferAsyncWithHttpInfo (string subscriptionId, string proposalId, DemandOfferBase demandOfferBase, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// GetAgreement - Fetches agreement with given agreement id.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <returns>Task of Agreement</returns>
        System.Threading.Tasks.Task<Agreement> GetAgreementAsync (string agreementId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// GetAgreement - Fetches agreement with given agreement id.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <returns>Task of ApiResponse (Agreement)</returns>
        System.Threading.Tasks.Task<ApiResponse<Agreement>> GetAgreementAsyncWithHttpInfo (string agreementId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// GetOffers - Fetches all active Offers which have been published by the Provider.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of List&lt;Offer&gt;</returns>
        System.Threading.Tasks.Task<List<Offer>> GetOffersAsync (System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// GetOffers - Fetches all active Offers which have been published by the Provider.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse (List&lt;Offer&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<Offer>>> GetOffersAsyncWithHttpInfo (System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// GetProposalDemand - Fetches Proposal (Demand) with given id.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <returns>Task of Proposal</returns>
        System.Threading.Tasks.Task<Proposal> GetProposalDemandAsync (string subscriptionId, string proposalId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// GetProposalDemand - Fetches Proposal (Demand) with given id.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <returns>Task of ApiResponse (Proposal)</returns>
        System.Threading.Tasks.Task<ApiResponse<Proposal>> GetProposalDemandAsyncWithHttpInfo (string subscriptionId, string proposalId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// QueryReplyOffers - Handles dynamic property query.
        /// </summary>
        /// <remarks>
        /// Sends a response to a received property value query.  The Market Matching Mechanism, when resolving the match relation for the specific Demand-Offer pair, is to detect the “dynamic” properties required (via constraints) by the other side. At this point, it is able to query the issuing node for those properties and submit the other side’s requested properties as the context of the query.  **Note**: The property query responses may be submitted in “chunks”, ie. the responder may choose to resolve ‘quick’/lightweight’ properties faster and provide response sooner, while still working on more time-consuming properties in the background. Therefore the response contains both the resolved properties, as well as list of properties which responder knows still require resolution.  **Note**: This method must be implemented for Market API Capability Level 2. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="queryId"></param>
        /// <param name="body"></param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task QueryReplyOffersAsync (string subscriptionId, string queryId, Object body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// QueryReplyOffers - Handles dynamic property query.
        /// </summary>
        /// <remarks>
        /// Sends a response to a received property value query.  The Market Matching Mechanism, when resolving the match relation for the specific Demand-Offer pair, is to detect the “dynamic” properties required (via constraints) by the other side. At this point, it is able to query the issuing node for those properties and submit the other side’s requested properties as the context of the query.  **Note**: The property query responses may be submitted in “chunks”, ie. the responder may choose to resolve ‘quick’/lightweight’ properties faster and provide response sooner, while still working on more time-consuming properties in the background. Therefore the response contains both the resolved properties, as well as list of properties which responder knows still require resolution.  **Note**: This method must be implemented for Market API Capability Level 2. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="queryId"></param>
        /// <param name="body"></param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> QueryReplyOffersAsyncWithHttpInfo (string subscriptionId, string queryId, Object body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// RejectAgreement - Rejects Agreement proposed by the Requestor.
        /// </summary>
        /// <remarks>
        /// The Requestor side is notified about the Provider’s decision to reject a negotiated agreement. This effectively stops the Agreement handshake.  **Note**: Mutually exclusive with &#x60;approveAgreement&#x60;. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RejectAgreementAsync (string agreementId, Dictionary<string, Object> requestBody = default(Dictionary<string, Object>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// RejectAgreement - Rejects Agreement proposed by the Requestor.
        /// </summary>
        /// <remarks>
        /// The Requestor side is notified about the Provider’s decision to reject a negotiated agreement. This effectively stops the Agreement handshake.  **Note**: Mutually exclusive with &#x60;approveAgreement&#x60;. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RejectAgreementAsyncWithHttpInfo (string agreementId, Dictionary<string, Object> requestBody = default(Dictionary<string, Object>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// RejectProposalDemand - Rejects Proposal (Demand).
        /// </summary>
        /// <remarks>
        /// Effectively ends a Negotiation chain - it explicitly indicates that the sender will not create another counter-Proposal. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RejectProposalDemandAsync (string subscriptionId, string proposalId, Dictionary<string, Object> requestBody = default(Dictionary<string, Object>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// RejectProposalDemand - Rejects Proposal (Demand).
        /// </summary>
        /// <remarks>
        /// Effectively ends a Negotiation chain - it explicitly indicates that the sender will not create another counter-Proposal. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RejectProposalDemandAsyncWithHttpInfo (string subscriptionId, string proposalId, Dictionary<string, Object> requestBody = default(Dictionary<string, Object>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// SubscribeOffer - Publishes Provider capabilities via Offer.
        /// </summary>
        /// <remarks>
        /// Offer object can be considered an \&quot;open\&quot; or public Offer, as it is not directed at a specific Requestor, but rather is sent to the market so that the matching mechanism implementation can associate relevant Demands.  **Note**: it is an \&quot;atomic\&quot; operation, ie. as soon as Subscription is placed, the Offer is published on the market. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="demandOfferBase"></param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> SubscribeOfferAsync (DemandOfferBase demandOfferBase, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// SubscribeOffer - Publishes Provider capabilities via Offer.
        /// </summary>
        /// <remarks>
        /// Offer object can be considered an \&quot;open\&quot; or public Offer, as it is not directed at a specific Requestor, but rather is sent to the market so that the matching mechanism implementation can associate relevant Demands.  **Note**: it is an \&quot;atomic\&quot; operation, ie. as soon as Subscription is placed, the Offer is published on the market. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="demandOfferBase"></param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> SubscribeOfferAsyncWithHttpInfo (DemandOfferBase demandOfferBase, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// TerminateAgreement - Terminates approved Agreement.
        /// </summary>
        /// <remarks>
        /// Method to finish/close the Agreement while in &#x60;Approved&#x60; state.  The other party gets notified about calling party decision to terminate a \&quot;running\&quot; agreement.  **Note**: Can be invoked at any time after Agreement was approved by both sides.  **Note**: Financial and reputational consequences are not defined by this specification. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task TerminateAgreementAsync (string agreementId, Dictionary<string, Object> requestBody = default(Dictionary<string, Object>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// TerminateAgreement - Terminates approved Agreement.
        /// </summary>
        /// <remarks>
        /// Method to finish/close the Agreement while in &#x60;Approved&#x60; state.  The other party gets notified about calling party decision to terminate a \&quot;running\&quot; agreement.  **Note**: Can be invoked at any time after Agreement was approved by both sides.  **Note**: Financial and reputational consequences are not defined by this specification. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> TerminateAgreementAsyncWithHttpInfo (string agreementId, Dictionary<string, Object> requestBody = default(Dictionary<string, Object>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// UnsubscribeOffer - Stop subscription for previously published Offer.
        /// </summary>
        /// <remarks>
        /// Stop receiving Proposals.  **Note**: this will terminate all pending &#x60;collectDemands&#x60; calls on this subscription. This implies, that client code should not &#x60;unsubscribeOffer&#x60; before it has received all expected/useful inputs from &#x60;collectDemands&#x60;. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task UnsubscribeOfferAsync (string subscriptionId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// UnsubscribeOffer - Stop subscription for previously published Offer.
        /// </summary>
        /// <remarks>
        /// Stop receiving Proposals.  **Note**: this will terminate all pending &#x60;collectDemands&#x60; calls on this subscription. This implies, that client code should not &#x60;unsubscribeOffer&#x60; before it has received all expected/useful inputs from &#x60;collectDemands&#x60;. 
        /// </remarks>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> UnsubscribeOfferAsyncWithHttpInfo (string subscriptionId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IProviderApi : IProviderApiSync, IProviderApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class ProviderApi : IProviderApi
    {
        private Golem.Common.Client.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="ProviderApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ProviderApi() : this((string) null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ProviderApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ProviderApi(String basePath)
        {
            this.Configuration = Golem.Common.Client.Client.Configuration.MergeConfigurations(
                Golem.Common.Client.Client.GlobalConfiguration.Instance,
                new Golem.Common.Client.Client.Configuration { BasePath = basePath }
            );
            this.Client = new Golem.Common.Client.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Golem.Common.Client.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = Golem.Common.Client.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ProviderApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public ProviderApi(Golem.Common.Client.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = Golem.Common.Client.Client.Configuration.MergeConfigurations(
                Golem.Common.Client.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new Golem.Common.Client.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Golem.Common.Client.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = Golem.Common.Client.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ProviderApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public ProviderApi(Golem.Common.Client.Client.ISynchronousClient client,Golem.Common.Client.Client.IAsynchronousClient asyncClient, Golem.Common.Client.Client.IReadableConfiguration configuration)
        {
            if(client == null) throw new ArgumentNullException("client");
            if(asyncClient == null) throw new ArgumentNullException("asyncClient");
            if(configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = Golem.Common.Client.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public Golem.Common.Client.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public Golem.Common.Client.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Golem.Common.Client.Client.IReadableConfiguration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Golem.Common.Client.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// ApproveAgreement - Approves Agreement proposed by the Reqestor. This is a blocking operation. The call may be aborted by Provider caller code. After the call is aborted or timed out, another &#x60;approveAgreement&#x60; call can be raised on the same &#x60;agreementId&#x60;.  **Note**: It is expected from the Provider node implementation to “ring-fence” the resources required to fulfill the Agreement before the ApproveAgreement is sent. However, the resources should not be fully committed until &#x60;Approved&#x60; response is received from the &#x60;approveAgreement&#x60; call.  **Note**: Mutually exclusive with &#x60;rejectAgreement&#x60;. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="appSessionId">A correlation/session identifier used for querying events related to an action where this appSessionId has been specified (optional)</param>
        /// <param name="timeout">Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party&#39;s response indefinitely)  (optional, default to 5.0F)</param>
        /// <returns></returns>
        public void ApproveAgreement (string agreementId, string appSessionId = default(string), float? timeout = default(float?))
        {
             ApproveAgreementWithHttpInfo(agreementId, appSessionId, timeout);
        }

        /// <summary>
        /// ApproveAgreement - Approves Agreement proposed by the Reqestor. This is a blocking operation. The call may be aborted by Provider caller code. After the call is aborted or timed out, another &#x60;approveAgreement&#x60; call can be raised on the same &#x60;agreementId&#x60;.  **Note**: It is expected from the Provider node implementation to “ring-fence” the resources required to fulfill the Agreement before the ApproveAgreement is sent. However, the resources should not be fully committed until &#x60;Approved&#x60; response is received from the &#x60;approveAgreement&#x60; call.  **Note**: Mutually exclusive with &#x60;rejectAgreement&#x60;. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="appSessionId">A correlation/session identifier used for querying events related to an action where this appSessionId has been specified (optional)</param>
        /// <param name="timeout">Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party&#39;s response indefinitely)  (optional, default to 5.0F)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Golem.Common.Client.Client.ApiResponse<Object> ApproveAgreementWithHttpInfo (string agreementId, string appSessionId = default(string), float? timeout = default(float?))
        {
            // verify the required parameter 'agreementId' is set
            if (agreementId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'agreementId' when calling ProviderApi->ApproveAgreement");

            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Golem.Common.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Golem.Common.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (agreementId != null)
                localVarRequestOptions.PathParameters.Add("agreementId", Golem.Common.Client.Client.ClientUtils.ParameterToString(agreementId)); // path parameter
            if (appSessionId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Golem.Common.Client.Client.ClientUtils.ParameterToMultiMap("", "appSessionId", appSessionId));
            }
            if (timeout != null)
            {
                localVarRequestOptions.QueryParameters.Add(Golem.Common.Client.Client.ClientUtils.ParameterToMultiMap("", "timeout", timeout));
            }

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/agreements/{agreementId}/approve", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ApproveAgreement", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// ApproveAgreement - Approves Agreement proposed by the Reqestor. This is a blocking operation. The call may be aborted by Provider caller code. After the call is aborted or timed out, another &#x60;approveAgreement&#x60; call can be raised on the same &#x60;agreementId&#x60;.  **Note**: It is expected from the Provider node implementation to “ring-fence” the resources required to fulfill the Agreement before the ApproveAgreement is sent. However, the resources should not be fully committed until &#x60;Approved&#x60; response is received from the &#x60;approveAgreement&#x60; call.  **Note**: Mutually exclusive with &#x60;rejectAgreement&#x60;. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="appSessionId">A correlation/session identifier used for querying events related to an action where this appSessionId has been specified (optional)</param>
        /// <param name="timeout">Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party&#39;s response indefinitely)  (optional, default to 5.0F)</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task ApproveAgreementAsync (string agreementId, string appSessionId = default(string), float? timeout = default(float?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
             await ApproveAgreementAsyncWithHttpInfo(agreementId, appSessionId, timeout, cancellationToken);

        }

        /// <summary>
        /// ApproveAgreement - Approves Agreement proposed by the Reqestor. This is a blocking operation. The call may be aborted by Provider caller code. After the call is aborted or timed out, another &#x60;approveAgreement&#x60; call can be raised on the same &#x60;agreementId&#x60;.  **Note**: It is expected from the Provider node implementation to “ring-fence” the resources required to fulfill the Agreement before the ApproveAgreement is sent. However, the resources should not be fully committed until &#x60;Approved&#x60; response is received from the &#x60;approveAgreement&#x60; call.  **Note**: Mutually exclusive with &#x60;rejectAgreement&#x60;. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="appSessionId">A correlation/session identifier used for querying events related to an action where this appSessionId has been specified (optional)</param>
        /// <param name="timeout">Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party&#39;s response indefinitely)  (optional, default to 5.0F)</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Golem.Common.Client.Client.ApiResponse<Object>> ApproveAgreementAsyncWithHttpInfo (string agreementId, string appSessionId = default(string), float? timeout = default(float?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'agreementId' is set
            if (agreementId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'agreementId' when calling ProviderApi->ApproveAgreement");


            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };
            
            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);
            
            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);
            
            if (agreementId != null)
                localVarRequestOptions.PathParameters.Add("agreementId", Golem.Common.Client.Client.ClientUtils.ParameterToString(agreementId)); // path parameter
            if (appSessionId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Golem.Common.Client.Client.ClientUtils.ParameterToMultiMap("", "appSessionId", appSessionId));
            }
            if (timeout != null)
            {
                localVarRequestOptions.QueryParameters.Add(Golem.Common.Client.Client.ClientUtils.ParameterToMultiMap("", "timeout", timeout));
            }

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/agreements/{agreementId}/approve", localVarRequestOptions, this.Configuration, cancellationToken);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ApproveAgreement", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// CollectAgreementEvents - Collects events related to an Agreement. This is a blocking operation. It will not return until there is at least one new event. All events are appearing on both sides equally.  Returns Agreement related events: * &#x60;AgreementApprovedEvent&#x60; - Indicates that the Agreement has been approved   by the Provider.   - The Provider is now ready to accept a request to start an Activity     as described in the negotiated agreement.   - The Providers’s corresponding &#x60;approveAgreement&#x60; call returns &#x60;Approved&#x60;     after this event is emitted.  * &#x60;AgreementRejectedEvent&#x60; - Indicates that the Provider has called   &#x60;rejectAgreement&#x60;, which effectively stops the Agreement handshake.   The Requestor may attempt to return to the Negotiation phase by sending   a new Proposal.  * &#x60;AgreementCancelledEvent&#x60; - Indicates that the Requestor has called   &#x60;cancelAgreement&#x60;, which effectively stops the Agreement handshake.  * &#x60;AgreementTerminatedEvent&#x60; - Indicates that the Agreement has been   terminated by specified party (contains signature). 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="timeout">Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)  (optional, default to 5.0F)</param>
        /// <param name="afterTimestamp">Apply only to records created later than the specified timestamp (optional)</param>
        /// <param name="maxEvents">Maximum number of events that server should return at once.  (optional, default to 10)</param>
        /// <param name="appSessionId">A correlation/session identifier used for querying events related to an action where this appSessionId has been specified (optional)</param>
        /// <returns>List&lt;AgreementEvent&gt;</returns>
        public List<AgreementEvent> CollectAgreementEvents (float? timeout = default(float?), DateTime? afterTimestamp = default(DateTime?), int? maxEvents = default(int?), string appSessionId = default(string))
        {
             Golem.Common.Client.Client.ApiResponse<List<AgreementEvent>> localVarResponse = CollectAgreementEventsWithHttpInfo(timeout, afterTimestamp, maxEvents, appSessionId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// CollectAgreementEvents - Collects events related to an Agreement. This is a blocking operation. It will not return until there is at least one new event. All events are appearing on both sides equally.  Returns Agreement related events: * &#x60;AgreementApprovedEvent&#x60; - Indicates that the Agreement has been approved   by the Provider.   - The Provider is now ready to accept a request to start an Activity     as described in the negotiated agreement.   - The Providers’s corresponding &#x60;approveAgreement&#x60; call returns &#x60;Approved&#x60;     after this event is emitted.  * &#x60;AgreementRejectedEvent&#x60; - Indicates that the Provider has called   &#x60;rejectAgreement&#x60;, which effectively stops the Agreement handshake.   The Requestor may attempt to return to the Negotiation phase by sending   a new Proposal.  * &#x60;AgreementCancelledEvent&#x60; - Indicates that the Requestor has called   &#x60;cancelAgreement&#x60;, which effectively stops the Agreement handshake.  * &#x60;AgreementTerminatedEvent&#x60; - Indicates that the Agreement has been   terminated by specified party (contains signature). 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="timeout">Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)  (optional, default to 5.0F)</param>
        /// <param name="afterTimestamp">Apply only to records created later than the specified timestamp (optional)</param>
        /// <param name="maxEvents">Maximum number of events that server should return at once.  (optional, default to 10)</param>
        /// <param name="appSessionId">A correlation/session identifier used for querying events related to an action where this appSessionId has been specified (optional)</param>
        /// <returns>ApiResponse of List&lt;AgreementEvent&gt;</returns>
        public Golem.Common.Client.Client.ApiResponse< List<AgreementEvent> > CollectAgreementEventsWithHttpInfo (float? timeout = default(float?), DateTime? afterTimestamp = default(DateTime?), int? maxEvents = default(int?), string appSessionId = default(string))
        {
            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Golem.Common.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Golem.Common.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (timeout != null)
            {
                localVarRequestOptions.QueryParameters.Add(Golem.Common.Client.Client.ClientUtils.ParameterToMultiMap("", "timeout", timeout));
            }
            if (afterTimestamp != null)
            {
                localVarRequestOptions.QueryParameters.Add(Golem.Common.Client.Client.ClientUtils.ParameterToMultiMap("", "afterTimestamp", afterTimestamp));
            }
            if (maxEvents != null)
            {
                localVarRequestOptions.QueryParameters.Add(Golem.Common.Client.Client.ClientUtils.ParameterToMultiMap("", "maxEvents", maxEvents));
            }
            if (appSessionId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Golem.Common.Client.Client.ClientUtils.ParameterToMultiMap("", "appSessionId", appSessionId));
            }

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get< List<AgreementEvent> >("/agreementEvents", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CollectAgreementEvents", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// CollectAgreementEvents - Collects events related to an Agreement. This is a blocking operation. It will not return until there is at least one new event. All events are appearing on both sides equally.  Returns Agreement related events: * &#x60;AgreementApprovedEvent&#x60; - Indicates that the Agreement has been approved   by the Provider.   - The Provider is now ready to accept a request to start an Activity     as described in the negotiated agreement.   - The Providers’s corresponding &#x60;approveAgreement&#x60; call returns &#x60;Approved&#x60;     after this event is emitted.  * &#x60;AgreementRejectedEvent&#x60; - Indicates that the Provider has called   &#x60;rejectAgreement&#x60;, which effectively stops the Agreement handshake.   The Requestor may attempt to return to the Negotiation phase by sending   a new Proposal.  * &#x60;AgreementCancelledEvent&#x60; - Indicates that the Requestor has called   &#x60;cancelAgreement&#x60;, which effectively stops the Agreement handshake.  * &#x60;AgreementTerminatedEvent&#x60; - Indicates that the Agreement has been   terminated by specified party (contains signature). 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="timeout">Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)  (optional, default to 5.0F)</param>
        /// <param name="afterTimestamp">Apply only to records created later than the specified timestamp (optional)</param>
        /// <param name="maxEvents">Maximum number of events that server should return at once.  (optional, default to 10)</param>
        /// <param name="appSessionId">A correlation/session identifier used for querying events related to an action where this appSessionId has been specified (optional)</param>
        /// <returns>Task of List&lt;AgreementEvent&gt;</returns>
        public async System.Threading.Tasks.Task<List<AgreementEvent>> CollectAgreementEventsAsync (float? timeout = default(float?), DateTime? afterTimestamp = default(DateTime?), int? maxEvents = default(int?), string appSessionId = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
             Golem.Common.Client.Client.ApiResponse<List<AgreementEvent>> localVarResponse = await CollectAgreementEventsAsyncWithHttpInfo(timeout, afterTimestamp, maxEvents, appSessionId,cancellationToken);
             return localVarResponse.Data;

        }

        /// <summary>
        /// CollectAgreementEvents - Collects events related to an Agreement. This is a blocking operation. It will not return until there is at least one new event. All events are appearing on both sides equally.  Returns Agreement related events: * &#x60;AgreementApprovedEvent&#x60; - Indicates that the Agreement has been approved   by the Provider.   - The Provider is now ready to accept a request to start an Activity     as described in the negotiated agreement.   - The Providers’s corresponding &#x60;approveAgreement&#x60; call returns &#x60;Approved&#x60;     after this event is emitted.  * &#x60;AgreementRejectedEvent&#x60; - Indicates that the Provider has called   &#x60;rejectAgreement&#x60;, which effectively stops the Agreement handshake.   The Requestor may attempt to return to the Negotiation phase by sending   a new Proposal.  * &#x60;AgreementCancelledEvent&#x60; - Indicates that the Requestor has called   &#x60;cancelAgreement&#x60;, which effectively stops the Agreement handshake.  * &#x60;AgreementTerminatedEvent&#x60; - Indicates that the Agreement has been   terminated by specified party (contains signature). 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="timeout">Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)  (optional, default to 5.0F)</param>
        /// <param name="afterTimestamp">Apply only to records created later than the specified timestamp (optional)</param>
        /// <param name="maxEvents">Maximum number of events that server should return at once.  (optional, default to 10)</param>
        /// <param name="appSessionId">A correlation/session identifier used for querying events related to an action where this appSessionId has been specified (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;AgreementEvent&gt;)</returns>
        public async System.Threading.Tasks.Task<Golem.Common.Client.Client.ApiResponse<List<AgreementEvent>>> CollectAgreementEventsAsyncWithHttpInfo (float? timeout = default(float?), DateTime? afterTimestamp = default(DateTime?), int? maxEvents = default(int?), string appSessionId = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };
            
            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);
            
            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);
            
            if (timeout != null)
            {
                localVarRequestOptions.QueryParameters.Add(Golem.Common.Client.Client.ClientUtils.ParameterToMultiMap("", "timeout", timeout));
            }
            if (afterTimestamp != null)
            {
                localVarRequestOptions.QueryParameters.Add(Golem.Common.Client.Client.ClientUtils.ParameterToMultiMap("", "afterTimestamp", afterTimestamp));
            }
            if (maxEvents != null)
            {
                localVarRequestOptions.QueryParameters.Add(Golem.Common.Client.Client.ClientUtils.ParameterToMultiMap("", "maxEvents", maxEvents));
            }
            if (appSessionId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Golem.Common.Client.Client.ClientUtils.ParameterToMultiMap("", "appSessionId", appSessionId));
            }

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<AgreementEvent>>("/agreementEvents", localVarRequestOptions, this.Configuration, cancellationToken);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CollectAgreementEvents", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// CollectDemands - Reads Market responses to published Offer. This is a blocking operation. It will not return until there is at least one new event. Returns Proposal related events: * &#x60;ProposalEvent&#x60; - Indicates that there is new Demand Proposal for this Offer. * &#x60;ProposalRejectedEvent&#x60; - Indicates that the Requestor has rejected   our previous Proposal related to this Offer. This effectively ends a   Negotiation chain - it explicitly indicates that the sender will not   create another counter-Proposal.  * &#x60;AgreementEvent&#x60; - Indicates that the Requestor is accepting our   previous Proposal and ask for our approval of the Agreement.  * &#x60;PropertyQueryEvent&#x60; - not supported yet.  **Note**: When &#x60;collectDemands&#x60; is waiting, simultaneous call to &#x60;unsubscribeOffer&#x60; on the same &#x60;subscriptionId&#x60; should result in \&quot;Subscription does not exist\&quot; error returned from &#x60;collectDemands&#x60;.  **Note**: Specification requires this endpoint to support list of specific Proposal Ids to listen for messages related only to specific Proposals. This is not covered yet. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="timeout">Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)  (optional, default to 5.0F)</param>
        /// <param name="maxEvents">Maximum number of events that server should return at once.  (optional, default to 10)</param>
        /// <returns>List&lt;Event&gt;</returns>
        public List<Event> CollectDemands (string subscriptionId, float? timeout = default(float?), int? maxEvents = default(int?))
        {
             Golem.Common.Client.Client.ApiResponse<List<Event>> localVarResponse = CollectDemandsWithHttpInfo(subscriptionId, timeout, maxEvents);
             return localVarResponse.Data;
        }

        /// <summary>
        /// CollectDemands - Reads Market responses to published Offer. This is a blocking operation. It will not return until there is at least one new event. Returns Proposal related events: * &#x60;ProposalEvent&#x60; - Indicates that there is new Demand Proposal for this Offer. * &#x60;ProposalRejectedEvent&#x60; - Indicates that the Requestor has rejected   our previous Proposal related to this Offer. This effectively ends a   Negotiation chain - it explicitly indicates that the sender will not   create another counter-Proposal.  * &#x60;AgreementEvent&#x60; - Indicates that the Requestor is accepting our   previous Proposal and ask for our approval of the Agreement.  * &#x60;PropertyQueryEvent&#x60; - not supported yet.  **Note**: When &#x60;collectDemands&#x60; is waiting, simultaneous call to &#x60;unsubscribeOffer&#x60; on the same &#x60;subscriptionId&#x60; should result in \&quot;Subscription does not exist\&quot; error returned from &#x60;collectDemands&#x60;.  **Note**: Specification requires this endpoint to support list of specific Proposal Ids to listen for messages related only to specific Proposals. This is not covered yet. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="timeout">Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)  (optional, default to 5.0F)</param>
        /// <param name="maxEvents">Maximum number of events that server should return at once.  (optional, default to 10)</param>
        /// <returns>ApiResponse of List&lt;Event&gt;</returns>
        public Golem.Common.Client.Client.ApiResponse< List<Event> > CollectDemandsWithHttpInfo (string subscriptionId, float? timeout = default(float?), int? maxEvents = default(int?))
        {
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'subscriptionId' when calling ProviderApi->CollectDemands");

            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Golem.Common.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Golem.Common.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (subscriptionId != null)
                localVarRequestOptions.PathParameters.Add("subscriptionId", Golem.Common.Client.Client.ClientUtils.ParameterToString(subscriptionId)); // path parameter
            if (timeout != null)
            {
                localVarRequestOptions.QueryParameters.Add(Golem.Common.Client.Client.ClientUtils.ParameterToMultiMap("", "timeout", timeout));
            }
            if (maxEvents != null)
            {
                localVarRequestOptions.QueryParameters.Add(Golem.Common.Client.Client.ClientUtils.ParameterToMultiMap("", "maxEvents", maxEvents));
            }

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get< List<Event> >("/offers/{subscriptionId}/events", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CollectDemands", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// CollectDemands - Reads Market responses to published Offer. This is a blocking operation. It will not return until there is at least one new event. Returns Proposal related events: * &#x60;ProposalEvent&#x60; - Indicates that there is new Demand Proposal for this Offer. * &#x60;ProposalRejectedEvent&#x60; - Indicates that the Requestor has rejected   our previous Proposal related to this Offer. This effectively ends a   Negotiation chain - it explicitly indicates that the sender will not   create another counter-Proposal.  * &#x60;AgreementEvent&#x60; - Indicates that the Requestor is accepting our   previous Proposal and ask for our approval of the Agreement.  * &#x60;PropertyQueryEvent&#x60; - not supported yet.  **Note**: When &#x60;collectDemands&#x60; is waiting, simultaneous call to &#x60;unsubscribeOffer&#x60; on the same &#x60;subscriptionId&#x60; should result in \&quot;Subscription does not exist\&quot; error returned from &#x60;collectDemands&#x60;.  **Note**: Specification requires this endpoint to support list of specific Proposal Ids to listen for messages related only to specific Proposals. This is not covered yet. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="timeout">Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)  (optional, default to 5.0F)</param>
        /// <param name="maxEvents">Maximum number of events that server should return at once.  (optional, default to 10)</param>
        /// <returns>Task of List&lt;Event&gt;</returns>
        public async System.Threading.Tasks.Task<List<Event>> CollectDemandsAsync (string subscriptionId, float? timeout = default(float?), int? maxEvents = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
             Golem.Common.Client.Client.ApiResponse<List<Event>> localVarResponse = await CollectDemandsAsyncWithHttpInfo(subscriptionId, timeout, maxEvents, cancellationToken);
             return localVarResponse.Data;

        }

        /// <summary>
        /// CollectDemands - Reads Market responses to published Offer. This is a blocking operation. It will not return until there is at least one new event. Returns Proposal related events: * &#x60;ProposalEvent&#x60; - Indicates that there is new Demand Proposal for this Offer. * &#x60;ProposalRejectedEvent&#x60; - Indicates that the Requestor has rejected   our previous Proposal related to this Offer. This effectively ends a   Negotiation chain - it explicitly indicates that the sender will not   create another counter-Proposal.  * &#x60;AgreementEvent&#x60; - Indicates that the Requestor is accepting our   previous Proposal and ask for our approval of the Agreement.  * &#x60;PropertyQueryEvent&#x60; - not supported yet.  **Note**: When &#x60;collectDemands&#x60; is waiting, simultaneous call to &#x60;unsubscribeOffer&#x60; on the same &#x60;subscriptionId&#x60; should result in \&quot;Subscription does not exist\&quot; error returned from &#x60;collectDemands&#x60;.  **Note**: Specification requires this endpoint to support list of specific Proposal Ids to listen for messages related only to specific Proposals. This is not covered yet. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="timeout">Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)  (optional, default to 5.0F)</param>
        /// <param name="maxEvents">Maximum number of events that server should return at once.  (optional, default to 10)</param>
        /// <returns>Task of ApiResponse (List&lt;Event&gt;)</returns>
        public async System.Threading.Tasks.Task<Golem.Common.Client.Client.ApiResponse<List<Event>>> CollectDemandsAsyncWithHttpInfo (string subscriptionId, float? timeout = default(float?), int? maxEvents = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'subscriptionId' when calling ProviderApi->CollectDemands");


            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };
            
            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);
            
            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);
            
            if (subscriptionId != null)
                localVarRequestOptions.PathParameters.Add("subscriptionId", Golem.Common.Client.Client.ClientUtils.ParameterToString(subscriptionId)); // path parameter
            if (timeout != null)
            {
                localVarRequestOptions.QueryParameters.Add(Golem.Common.Client.Client.ClientUtils.ParameterToMultiMap("", "timeout", timeout));
            }
            if (maxEvents != null)
            {
                localVarRequestOptions.QueryParameters.Add(Golem.Common.Client.Client.ClientUtils.ParameterToMultiMap("", "maxEvents", maxEvents));
            }

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<Event>>("/offers/{subscriptionId}/events", localVarRequestOptions, this.Configuration, cancellationToken);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CollectDemands", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// CounterProposalOffer - Responds with a bespoke Offer to received Demand. Creates and sends a modified version of original Offer (a counter-proposal) adjusted to previously received Proposal (ie. Demand). Changes Proposal state to &#x60;Draft&#x60;. Returns created Proposal id. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <param name="demandOfferBase"></param>
        /// <returns>string</returns>
        public string CounterProposalOffer (string subscriptionId, string proposalId, DemandOfferBase demandOfferBase)
        {
             Golem.Common.Client.Client.ApiResponse<string> localVarResponse = CounterProposalOfferWithHttpInfo(subscriptionId, proposalId, demandOfferBase);
             return localVarResponse.Data;
        }

        /// <summary>
        /// CounterProposalOffer - Responds with a bespoke Offer to received Demand. Creates and sends a modified version of original Offer (a counter-proposal) adjusted to previously received Proposal (ie. Demand). Changes Proposal state to &#x60;Draft&#x60;. Returns created Proposal id. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <param name="demandOfferBase"></param>
        /// <returns>ApiResponse of string</returns>
        public Golem.Common.Client.Client.ApiResponse< string > CounterProposalOfferWithHttpInfo (string subscriptionId, string proposalId, DemandOfferBase demandOfferBase)
        {
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'subscriptionId' when calling ProviderApi->CounterProposalOffer");

            // verify the required parameter 'proposalId' is set
            if (proposalId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'proposalId' when calling ProviderApi->CounterProposalOffer");

            // verify the required parameter 'demandOfferBase' is set
            if (demandOfferBase == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'demandOfferBase' when calling ProviderApi->CounterProposalOffer");

            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Golem.Common.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Golem.Common.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (subscriptionId != null)
                localVarRequestOptions.PathParameters.Add("subscriptionId", Golem.Common.Client.Client.ClientUtils.ParameterToString(subscriptionId)); // path parameter
            if (proposalId != null)
                localVarRequestOptions.PathParameters.Add("proposalId", Golem.Common.Client.Client.ClientUtils.ParameterToString(proposalId)); // path parameter
            localVarRequestOptions.Data = demandOfferBase;

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post< string >("/offers/{subscriptionId}/proposals/{proposalId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CounterProposalOffer", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// CounterProposalOffer - Responds with a bespoke Offer to received Demand. Creates and sends a modified version of original Offer (a counter-proposal) adjusted to previously received Proposal (ie. Demand). Changes Proposal state to &#x60;Draft&#x60;. Returns created Proposal id. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <param name="demandOfferBase"></param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> CounterProposalOfferAsync (string subscriptionId, string proposalId, DemandOfferBase demandOfferBase, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
             Golem.Common.Client.Client.ApiResponse<string> localVarResponse = await CounterProposalOfferAsyncWithHttpInfo(subscriptionId, proposalId, demandOfferBase, cancellationToken);
             return localVarResponse.Data;

        }

        /// <summary>
        /// CounterProposalOffer - Responds with a bespoke Offer to received Demand. Creates and sends a modified version of original Offer (a counter-proposal) adjusted to previously received Proposal (ie. Demand). Changes Proposal state to &#x60;Draft&#x60;. Returns created Proposal id. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <param name="demandOfferBase"></param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<Golem.Common.Client.Client.ApiResponse<string>> CounterProposalOfferAsyncWithHttpInfo (string subscriptionId, string proposalId, DemandOfferBase demandOfferBase, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'subscriptionId' when calling ProviderApi->CounterProposalOffer");

            // verify the required parameter 'proposalId' is set
            if (proposalId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'proposalId' when calling ProviderApi->CounterProposalOffer");

            // verify the required parameter 'demandOfferBase' is set
            if (demandOfferBase == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'demandOfferBase' when calling ProviderApi->CounterProposalOffer");


            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };
            
            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);
            
            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);
            
            if (subscriptionId != null)
                localVarRequestOptions.PathParameters.Add("subscriptionId", Golem.Common.Client.Client.ClientUtils.ParameterToString(subscriptionId)); // path parameter
            if (proposalId != null)
                localVarRequestOptions.PathParameters.Add("proposalId", Golem.Common.Client.Client.ClientUtils.ParameterToString(proposalId)); // path parameter
            localVarRequestOptions.Data = demandOfferBase;

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<string>("/offers/{subscriptionId}/proposals/{proposalId}", localVarRequestOptions, this.Configuration, cancellationToken);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CounterProposalOffer", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// GetAgreement - Fetches agreement with given agreement id. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <returns>Agreement</returns>
        public Agreement GetAgreement (string agreementId)
        {
             Golem.Common.Client.Client.ApiResponse<Agreement> localVarResponse = GetAgreementWithHttpInfo(agreementId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// GetAgreement - Fetches agreement with given agreement id. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <returns>ApiResponse of Agreement</returns>
        public Golem.Common.Client.Client.ApiResponse< Agreement > GetAgreementWithHttpInfo (string agreementId)
        {
            // verify the required parameter 'agreementId' is set
            if (agreementId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'agreementId' when calling ProviderApi->GetAgreement");

            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Golem.Common.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Golem.Common.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (agreementId != null)
                localVarRequestOptions.PathParameters.Add("agreementId", Golem.Common.Client.Client.ClientUtils.ParameterToString(agreementId)); // path parameter

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get< Agreement >("/agreements/{agreementId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetAgreement", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// GetAgreement - Fetches agreement with given agreement id. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <returns>Task of Agreement</returns>
        public async System.Threading.Tasks.Task<Agreement> GetAgreementAsync (string agreementId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
             Golem.Common.Client.Client.ApiResponse<Agreement> localVarResponse = await GetAgreementAsyncWithHttpInfo(agreementId, cancellationToken);
             return localVarResponse.Data;

        }

        /// <summary>
        /// GetAgreement - Fetches agreement with given agreement id. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <returns>Task of ApiResponse (Agreement)</returns>
        public async System.Threading.Tasks.Task<Golem.Common.Client.Client.ApiResponse<Agreement>> GetAgreementAsyncWithHttpInfo (string agreementId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'agreementId' is set
            if (agreementId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'agreementId' when calling ProviderApi->GetAgreement");


            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };
            
            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);
            
            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);
            
            if (agreementId != null)
                localVarRequestOptions.PathParameters.Add("agreementId", Golem.Common.Client.Client.ClientUtils.ParameterToString(agreementId)); // path parameter

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<Agreement>("/agreements/{agreementId}", localVarRequestOptions, this.Configuration, cancellationToken);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetAgreement", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// GetOffers - Fetches all active Offers which have been published by the Provider. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>List&lt;Offer&gt;</returns>
        public List<Offer> GetOffers ()
        {
             Golem.Common.Client.Client.ApiResponse<List<Offer>> localVarResponse = GetOffersWithHttpInfo();
             return localVarResponse.Data;
        }

        /// <summary>
        /// GetOffers - Fetches all active Offers which have been published by the Provider. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of List&lt;Offer&gt;</returns>
        public Golem.Common.Client.Client.ApiResponse< List<Offer> > GetOffersWithHttpInfo ()
        {
            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Golem.Common.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Golem.Common.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);


            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get< List<Offer> >("/offers", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetOffers", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// GetOffers - Fetches all active Offers which have been published by the Provider. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of List&lt;Offer&gt;</returns>
        public async System.Threading.Tasks.Task<List<Offer>> GetOffersAsync (System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
             Golem.Common.Client.Client.ApiResponse<List<Offer>> localVarResponse = await GetOffersAsyncWithHttpInfo(cancellationToken);
             return localVarResponse.Data;

        }

        /// <summary>
        /// GetOffers - Fetches all active Offers which have been published by the Provider. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse (List&lt;Offer&gt;)</returns>
        public async System.Threading.Tasks.Task<Golem.Common.Client.Client.ApiResponse<List<Offer>>> GetOffersAsyncWithHttpInfo (System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };
            
            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);
            
            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);
            

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<Offer>>("/offers", localVarRequestOptions, this.Configuration, cancellationToken);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetOffers", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// GetProposalDemand - Fetches Proposal (Demand) with given id. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <returns>Proposal</returns>
        public Proposal GetProposalDemand (string subscriptionId, string proposalId)
        {
             Golem.Common.Client.Client.ApiResponse<Proposal> localVarResponse = GetProposalDemandWithHttpInfo(subscriptionId, proposalId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// GetProposalDemand - Fetches Proposal (Demand) with given id. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <returns>ApiResponse of Proposal</returns>
        public Golem.Common.Client.Client.ApiResponse< Proposal > GetProposalDemandWithHttpInfo (string subscriptionId, string proposalId)
        {
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'subscriptionId' when calling ProviderApi->GetProposalDemand");

            // verify the required parameter 'proposalId' is set
            if (proposalId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'proposalId' when calling ProviderApi->GetProposalDemand");

            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Golem.Common.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Golem.Common.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (subscriptionId != null)
                localVarRequestOptions.PathParameters.Add("subscriptionId", Golem.Common.Client.Client.ClientUtils.ParameterToString(subscriptionId)); // path parameter
            if (proposalId != null)
                localVarRequestOptions.PathParameters.Add("proposalId", Golem.Common.Client.Client.ClientUtils.ParameterToString(proposalId)); // path parameter

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get< Proposal >("/offers/{subscriptionId}/proposals/{proposalId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetProposalDemand", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// GetProposalDemand - Fetches Proposal (Demand) with given id. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <returns>Task of Proposal</returns>
        public async System.Threading.Tasks.Task<Proposal> GetProposalDemandAsync (string subscriptionId, string proposalId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
             Golem.Common.Client.Client.ApiResponse<Proposal> localVarResponse = await GetProposalDemandAsyncWithHttpInfo(subscriptionId, proposalId, cancellationToken);
             return localVarResponse.Data;

        }

        /// <summary>
        /// GetProposalDemand - Fetches Proposal (Demand) with given id. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <returns>Task of ApiResponse (Proposal)</returns>
        public async System.Threading.Tasks.Task<Golem.Common.Client.Client.ApiResponse<Proposal>> GetProposalDemandAsyncWithHttpInfo (string subscriptionId, string proposalId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'subscriptionId' when calling ProviderApi->GetProposalDemand");

            // verify the required parameter 'proposalId' is set
            if (proposalId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'proposalId' when calling ProviderApi->GetProposalDemand");


            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };
            
            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);
            
            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);
            
            if (subscriptionId != null)
                localVarRequestOptions.PathParameters.Add("subscriptionId", Golem.Common.Client.Client.ClientUtils.ParameterToString(subscriptionId)); // path parameter
            if (proposalId != null)
                localVarRequestOptions.PathParameters.Add("proposalId", Golem.Common.Client.Client.ClientUtils.ParameterToString(proposalId)); // path parameter

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<Proposal>("/offers/{subscriptionId}/proposals/{proposalId}", localVarRequestOptions, this.Configuration, cancellationToken);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetProposalDemand", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// QueryReplyOffers - Handles dynamic property query. Sends a response to a received property value query.  The Market Matching Mechanism, when resolving the match relation for the specific Demand-Offer pair, is to detect the “dynamic” properties required (via constraints) by the other side. At this point, it is able to query the issuing node for those properties and submit the other side’s requested properties as the context of the query.  **Note**: The property query responses may be submitted in “chunks”, ie. the responder may choose to resolve ‘quick’/lightweight’ properties faster and provide response sooner, while still working on more time-consuming properties in the background. Therefore the response contains both the resolved properties, as well as list of properties which responder knows still require resolution.  **Note**: This method must be implemented for Market API Capability Level 2. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="queryId"></param>
        /// <param name="body"></param>
        /// <returns></returns>
        public void QueryReplyOffers (string subscriptionId, string queryId, Object body)
        {
             QueryReplyOffersWithHttpInfo(subscriptionId, queryId, body);
        }

        /// <summary>
        /// QueryReplyOffers - Handles dynamic property query. Sends a response to a received property value query.  The Market Matching Mechanism, when resolving the match relation for the specific Demand-Offer pair, is to detect the “dynamic” properties required (via constraints) by the other side. At this point, it is able to query the issuing node for those properties and submit the other side’s requested properties as the context of the query.  **Note**: The property query responses may be submitted in “chunks”, ie. the responder may choose to resolve ‘quick’/lightweight’ properties faster and provide response sooner, while still working on more time-consuming properties in the background. Therefore the response contains both the resolved properties, as well as list of properties which responder knows still require resolution.  **Note**: This method must be implemented for Market API Capability Level 2. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="queryId"></param>
        /// <param name="body"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Golem.Common.Client.Client.ApiResponse<Object> QueryReplyOffersWithHttpInfo (string subscriptionId, string queryId, Object body)
        {
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'subscriptionId' when calling ProviderApi->QueryReplyOffers");

            // verify the required parameter 'queryId' is set
            if (queryId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'queryId' when calling ProviderApi->QueryReplyOffers");

            // verify the required parameter 'body' is set
            if (body == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'body' when calling ProviderApi->QueryReplyOffers");

            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Golem.Common.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Golem.Common.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (subscriptionId != null)
                localVarRequestOptions.PathParameters.Add("subscriptionId", Golem.Common.Client.Client.ClientUtils.ParameterToString(subscriptionId)); // path parameter
            if (queryId != null)
                localVarRequestOptions.PathParameters.Add("queryId", Golem.Common.Client.Client.ClientUtils.ParameterToString(queryId)); // path parameter
            localVarRequestOptions.Data = body;

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/offers/{subscriptionId}/propertyQuery/{queryId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("QueryReplyOffers", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// QueryReplyOffers - Handles dynamic property query. Sends a response to a received property value query.  The Market Matching Mechanism, when resolving the match relation for the specific Demand-Offer pair, is to detect the “dynamic” properties required (via constraints) by the other side. At this point, it is able to query the issuing node for those properties and submit the other side’s requested properties as the context of the query.  **Note**: The property query responses may be submitted in “chunks”, ie. the responder may choose to resolve ‘quick’/lightweight’ properties faster and provide response sooner, while still working on more time-consuming properties in the background. Therefore the response contains both the resolved properties, as well as list of properties which responder knows still require resolution.  **Note**: This method must be implemented for Market API Capability Level 2. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="queryId"></param>
        /// <param name="body"></param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task QueryReplyOffersAsync (string subscriptionId, string queryId, Object body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
             await QueryReplyOffersAsyncWithHttpInfo(subscriptionId, queryId, body, cancellationToken);

        }

        /// <summary>
        /// QueryReplyOffers - Handles dynamic property query. Sends a response to a received property value query.  The Market Matching Mechanism, when resolving the match relation for the specific Demand-Offer pair, is to detect the “dynamic” properties required (via constraints) by the other side. At this point, it is able to query the issuing node for those properties and submit the other side’s requested properties as the context of the query.  **Note**: The property query responses may be submitted in “chunks”, ie. the responder may choose to resolve ‘quick’/lightweight’ properties faster and provide response sooner, while still working on more time-consuming properties in the background. Therefore the response contains both the resolved properties, as well as list of properties which responder knows still require resolution.  **Note**: This method must be implemented for Market API Capability Level 2. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="queryId"></param>
        /// <param name="body"></param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Golem.Common.Client.Client.ApiResponse<Object>> QueryReplyOffersAsyncWithHttpInfo (string subscriptionId, string queryId, Object body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'subscriptionId' when calling ProviderApi->QueryReplyOffers");

            // verify the required parameter 'queryId' is set
            if (queryId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'queryId' when calling ProviderApi->QueryReplyOffers");

            // verify the required parameter 'body' is set
            if (body == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'body' when calling ProviderApi->QueryReplyOffers");


            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };
            
            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);
            
            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);
            
            if (subscriptionId != null)
                localVarRequestOptions.PathParameters.Add("subscriptionId", Golem.Common.Client.Client.ClientUtils.ParameterToString(subscriptionId)); // path parameter
            if (queryId != null)
                localVarRequestOptions.PathParameters.Add("queryId", Golem.Common.Client.Client.ClientUtils.ParameterToString(queryId)); // path parameter
            localVarRequestOptions.Data = body;

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/offers/{subscriptionId}/propertyQuery/{queryId}", localVarRequestOptions, this.Configuration, cancellationToken);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("QueryReplyOffers", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// RejectAgreement - Rejects Agreement proposed by the Requestor. The Requestor side is notified about the Provider’s decision to reject a negotiated agreement. This effectively stops the Agreement handshake.  **Note**: Mutually exclusive with &#x60;approveAgreement&#x60;. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns></returns>
        public void RejectAgreement (string agreementId, Dictionary<string, Object> requestBody = default(Dictionary<string, Object>))
        {
             RejectAgreementWithHttpInfo(agreementId, requestBody);
        }

        /// <summary>
        /// RejectAgreement - Rejects Agreement proposed by the Requestor. The Requestor side is notified about the Provider’s decision to reject a negotiated agreement. This effectively stops the Agreement handshake.  **Note**: Mutually exclusive with &#x60;approveAgreement&#x60;. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Golem.Common.Client.Client.ApiResponse<Object> RejectAgreementWithHttpInfo (string agreementId, Dictionary<string, Object> requestBody = default(Dictionary<string, Object>))
        {
            // verify the required parameter 'agreementId' is set
            if (agreementId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'agreementId' when calling ProviderApi->RejectAgreement");

            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Golem.Common.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Golem.Common.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (agreementId != null)
                localVarRequestOptions.PathParameters.Add("agreementId", Golem.Common.Client.Client.ClientUtils.ParameterToString(agreementId)); // path parameter
            localVarRequestOptions.Data = requestBody;

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/agreements/{agreementId}/reject", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RejectAgreement", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// RejectAgreement - Rejects Agreement proposed by the Requestor. The Requestor side is notified about the Provider’s decision to reject a negotiated agreement. This effectively stops the Agreement handshake.  **Note**: Mutually exclusive with &#x60;approveAgreement&#x60;. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RejectAgreementAsync (string agreementId, Dictionary<string, Object> requestBody = default(Dictionary<string, Object>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
             await RejectAgreementAsyncWithHttpInfo(agreementId, requestBody, cancellationToken);

        }

        /// <summary>
        /// RejectAgreement - Rejects Agreement proposed by the Requestor. The Requestor side is notified about the Provider’s decision to reject a negotiated agreement. This effectively stops the Agreement handshake.  **Note**: Mutually exclusive with &#x60;approveAgreement&#x60;. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Golem.Common.Client.Client.ApiResponse<Object>> RejectAgreementAsyncWithHttpInfo (string agreementId, Dictionary<string, Object> requestBody = default(Dictionary<string, Object>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'agreementId' is set
            if (agreementId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'agreementId' when calling ProviderApi->RejectAgreement");


            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };
            
            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);
            
            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);
            
            if (agreementId != null)
                localVarRequestOptions.PathParameters.Add("agreementId", Golem.Common.Client.Client.ClientUtils.ParameterToString(agreementId)); // path parameter
            localVarRequestOptions.Data = requestBody;

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/agreements/{agreementId}/reject", localVarRequestOptions, this.Configuration, cancellationToken);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RejectAgreement", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// RejectProposalDemand - Rejects Proposal (Demand). Effectively ends a Negotiation chain - it explicitly indicates that the sender will not create another counter-Proposal. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns></returns>
        public void RejectProposalDemand (string subscriptionId, string proposalId, Dictionary<string, Object> requestBody = default(Dictionary<string, Object>))
        {
             RejectProposalDemandWithHttpInfo(subscriptionId, proposalId, requestBody);
        }

        /// <summary>
        /// RejectProposalDemand - Rejects Proposal (Demand). Effectively ends a Negotiation chain - it explicitly indicates that the sender will not create another counter-Proposal. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Golem.Common.Client.Client.ApiResponse<Object> RejectProposalDemandWithHttpInfo (string subscriptionId, string proposalId, Dictionary<string, Object> requestBody = default(Dictionary<string, Object>))
        {
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'subscriptionId' when calling ProviderApi->RejectProposalDemand");

            // verify the required parameter 'proposalId' is set
            if (proposalId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'proposalId' when calling ProviderApi->RejectProposalDemand");

            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Golem.Common.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Golem.Common.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (subscriptionId != null)
                localVarRequestOptions.PathParameters.Add("subscriptionId", Golem.Common.Client.Client.ClientUtils.ParameterToString(subscriptionId)); // path parameter
            if (proposalId != null)
                localVarRequestOptions.PathParameters.Add("proposalId", Golem.Common.Client.Client.ClientUtils.ParameterToString(proposalId)); // path parameter
            localVarRequestOptions.Data = requestBody;

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/offers/{subscriptionId}/proposals/{proposalId}/reject", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RejectProposalDemand", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// RejectProposalDemand - Rejects Proposal (Demand). Effectively ends a Negotiation chain - it explicitly indicates that the sender will not create another counter-Proposal. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RejectProposalDemandAsync (string subscriptionId, string proposalId, Dictionary<string, Object> requestBody = default(Dictionary<string, Object>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
             await RejectProposalDemandAsyncWithHttpInfo(subscriptionId, proposalId, requestBody, cancellationToken);

        }

        /// <summary>
        /// RejectProposalDemand - Rejects Proposal (Demand). Effectively ends a Negotiation chain - it explicitly indicates that the sender will not create another counter-Proposal. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <param name="proposalId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Golem.Common.Client.Client.ApiResponse<Object>> RejectProposalDemandAsyncWithHttpInfo (string subscriptionId, string proposalId, Dictionary<string, Object> requestBody = default(Dictionary<string, Object>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'subscriptionId' when calling ProviderApi->RejectProposalDemand");

            // verify the required parameter 'proposalId' is set
            if (proposalId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'proposalId' when calling ProviderApi->RejectProposalDemand");


            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };
            
            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);
            
            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);
            
            if (subscriptionId != null)
                localVarRequestOptions.PathParameters.Add("subscriptionId", Golem.Common.Client.Client.ClientUtils.ParameterToString(subscriptionId)); // path parameter
            if (proposalId != null)
                localVarRequestOptions.PathParameters.Add("proposalId", Golem.Common.Client.Client.ClientUtils.ParameterToString(proposalId)); // path parameter
            localVarRequestOptions.Data = requestBody;

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/offers/{subscriptionId}/proposals/{proposalId}/reject", localVarRequestOptions, this.Configuration, cancellationToken);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RejectProposalDemand", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// SubscribeOffer - Publishes Provider capabilities via Offer. Offer object can be considered an \&quot;open\&quot; or public Offer, as it is not directed at a specific Requestor, but rather is sent to the market so that the matching mechanism implementation can associate relevant Demands.  **Note**: it is an \&quot;atomic\&quot; operation, ie. as soon as Subscription is placed, the Offer is published on the market. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="demandOfferBase"></param>
        /// <returns>string</returns>
        public string SubscribeOffer (DemandOfferBase demandOfferBase)
        {
             Golem.Common.Client.Client.ApiResponse<string> localVarResponse = SubscribeOfferWithHttpInfo(demandOfferBase);
             return localVarResponse.Data;
        }

        /// <summary>
        /// SubscribeOffer - Publishes Provider capabilities via Offer. Offer object can be considered an \&quot;open\&quot; or public Offer, as it is not directed at a specific Requestor, but rather is sent to the market so that the matching mechanism implementation can associate relevant Demands.  **Note**: it is an \&quot;atomic\&quot; operation, ie. as soon as Subscription is placed, the Offer is published on the market. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="demandOfferBase"></param>
        /// <returns>ApiResponse of string</returns>
        public Golem.Common.Client.Client.ApiResponse< string > SubscribeOfferWithHttpInfo (DemandOfferBase demandOfferBase)
        {
            // verify the required parameter 'demandOfferBase' is set
            if (demandOfferBase == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'demandOfferBase' when calling ProviderApi->SubscribeOffer");

            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Golem.Common.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Golem.Common.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = demandOfferBase;

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post< string >("/offers", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SubscribeOffer", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// SubscribeOffer - Publishes Provider capabilities via Offer. Offer object can be considered an \&quot;open\&quot; or public Offer, as it is not directed at a specific Requestor, but rather is sent to the market so that the matching mechanism implementation can associate relevant Demands.  **Note**: it is an \&quot;atomic\&quot; operation, ie. as soon as Subscription is placed, the Offer is published on the market. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="demandOfferBase"></param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> SubscribeOfferAsync (DemandOfferBase demandOfferBase, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
             Golem.Common.Client.Client.ApiResponse<string> localVarResponse = await SubscribeOfferAsyncWithHttpInfo(demandOfferBase, cancellationToken);
             return localVarResponse.Data;

        }

        /// <summary>
        /// SubscribeOffer - Publishes Provider capabilities via Offer. Offer object can be considered an \&quot;open\&quot; or public Offer, as it is not directed at a specific Requestor, but rather is sent to the market so that the matching mechanism implementation can associate relevant Demands.  **Note**: it is an \&quot;atomic\&quot; operation, ie. as soon as Subscription is placed, the Offer is published on the market. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="demandOfferBase"></param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<Golem.Common.Client.Client.ApiResponse<string>> SubscribeOfferAsyncWithHttpInfo (DemandOfferBase demandOfferBase, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'demandOfferBase' is set
            if (demandOfferBase == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'demandOfferBase' when calling ProviderApi->SubscribeOffer");


            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };
            
            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);
            
            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);
            
            localVarRequestOptions.Data = demandOfferBase;

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<string>("/offers", localVarRequestOptions, this.Configuration, cancellationToken);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SubscribeOffer", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// TerminateAgreement - Terminates approved Agreement. Method to finish/close the Agreement while in &#x60;Approved&#x60; state.  The other party gets notified about calling party decision to terminate a \&quot;running\&quot; agreement.  **Note**: Can be invoked at any time after Agreement was approved by both sides.  **Note**: Financial and reputational consequences are not defined by this specification. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns></returns>
        public void TerminateAgreement (string agreementId, Dictionary<string, Object> requestBody = default(Dictionary<string, Object>))
        {
             TerminateAgreementWithHttpInfo(agreementId, requestBody);
        }

        /// <summary>
        /// TerminateAgreement - Terminates approved Agreement. Method to finish/close the Agreement while in &#x60;Approved&#x60; state.  The other party gets notified about calling party decision to terminate a \&quot;running\&quot; agreement.  **Note**: Can be invoked at any time after Agreement was approved by both sides.  **Note**: Financial and reputational consequences are not defined by this specification. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Golem.Common.Client.Client.ApiResponse<Object> TerminateAgreementWithHttpInfo (string agreementId, Dictionary<string, Object> requestBody = default(Dictionary<string, Object>))
        {
            // verify the required parameter 'agreementId' is set
            if (agreementId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'agreementId' when calling ProviderApi->TerminateAgreement");

            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Golem.Common.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Golem.Common.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (agreementId != null)
                localVarRequestOptions.PathParameters.Add("agreementId", Golem.Common.Client.Client.ClientUtils.ParameterToString(agreementId)); // path parameter
            localVarRequestOptions.Data = requestBody;

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/agreements/{agreementId}/terminate", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("TerminateAgreement", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// TerminateAgreement - Terminates approved Agreement. Method to finish/close the Agreement while in &#x60;Approved&#x60; state.  The other party gets notified about calling party decision to terminate a \&quot;running\&quot; agreement.  **Note**: Can be invoked at any time after Agreement was approved by both sides.  **Note**: Financial and reputational consequences are not defined by this specification. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task TerminateAgreementAsync (string agreementId, Dictionary<string, Object> requestBody = default(Dictionary<string, Object>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
             await TerminateAgreementAsyncWithHttpInfo(agreementId, requestBody, cancellationToken);

        }

        /// <summary>
        /// TerminateAgreement - Terminates approved Agreement. Method to finish/close the Agreement while in &#x60;Approved&#x60; state.  The other party gets notified about calling party decision to terminate a \&quot;running\&quot; agreement.  **Note**: Can be invoked at any time after Agreement was approved by both sides.  **Note**: Financial and reputational consequences are not defined by this specification. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agreementId"></param>
        /// <param name="requestBody"> (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Golem.Common.Client.Client.ApiResponse<Object>> TerminateAgreementAsyncWithHttpInfo (string agreementId, Dictionary<string, Object> requestBody = default(Dictionary<string, Object>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'agreementId' is set
            if (agreementId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'agreementId' when calling ProviderApi->TerminateAgreement");


            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };
            
            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);
            
            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);
            
            if (agreementId != null)
                localVarRequestOptions.PathParameters.Add("agreementId", Golem.Common.Client.Client.ClientUtils.ParameterToString(agreementId)); // path parameter
            localVarRequestOptions.Data = requestBody;

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/agreements/{agreementId}/terminate", localVarRequestOptions, this.Configuration, cancellationToken);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("TerminateAgreement", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// UnsubscribeOffer - Stop subscription for previously published Offer. Stop receiving Proposals.  **Note**: this will terminate all pending &#x60;collectDemands&#x60; calls on this subscription. This implies, that client code should not &#x60;unsubscribeOffer&#x60; before it has received all expected/useful inputs from &#x60;collectDemands&#x60;. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <returns></returns>
        public void UnsubscribeOffer (string subscriptionId)
        {
             UnsubscribeOfferWithHttpInfo(subscriptionId);
        }

        /// <summary>
        /// UnsubscribeOffer - Stop subscription for previously published Offer. Stop receiving Proposals.  **Note**: this will terminate all pending &#x60;collectDemands&#x60; calls on this subscription. This implies, that client code should not &#x60;unsubscribeOffer&#x60; before it has received all expected/useful inputs from &#x60;collectDemands&#x60;. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Golem.Common.Client.Client.ApiResponse<Object> UnsubscribeOfferWithHttpInfo (string subscriptionId)
        {
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'subscriptionId' when calling ProviderApi->UnsubscribeOffer");

            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Golem.Common.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Golem.Common.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (subscriptionId != null)
                localVarRequestOptions.PathParameters.Add("subscriptionId", Golem.Common.Client.Client.ClientUtils.ParameterToString(subscriptionId)); // path parameter

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/offers/{subscriptionId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UnsubscribeOffer", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// UnsubscribeOffer - Stop subscription for previously published Offer. Stop receiving Proposals.  **Note**: this will terminate all pending &#x60;collectDemands&#x60; calls on this subscription. This implies, that client code should not &#x60;unsubscribeOffer&#x60; before it has received all expected/useful inputs from &#x60;collectDemands&#x60;. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task UnsubscribeOfferAsync (string subscriptionId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
             await UnsubscribeOfferAsyncWithHttpInfo(subscriptionId, cancellationToken);

        }

        /// <summary>
        /// UnsubscribeOffer - Stop subscription for previously published Offer. Stop receiving Proposals.  **Note**: this will terminate all pending &#x60;collectDemands&#x60; calls on this subscription. This implies, that client code should not &#x60;unsubscribeOffer&#x60; before it has received all expected/useful inputs from &#x60;collectDemands&#x60;. 
        /// </summary>
        /// <exception cref="Golem.Common.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId"></param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Golem.Common.Client.Client.ApiResponse<Object>> UnsubscribeOfferAsyncWithHttpInfo (string subscriptionId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new Golem.Common.Client.Client.ApiException(400, "Missing required parameter 'subscriptionId' when calling ProviderApi->UnsubscribeOffer");


            Golem.Common.Client.Client.RequestOptions localVarRequestOptions = new Golem.Common.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };
            
            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);
            
            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);
            
            if (subscriptionId != null)
                localVarRequestOptions.PathParameters.Add("subscriptionId", Golem.Common.Client.Client.ClientUtils.ParameterToString(subscriptionId)); // path parameter

            // authentication (app_key) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Golem.Common.Client.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/offers/{subscriptionId}", localVarRequestOptions, this.Configuration, cancellationToken);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UnsubscribeOffer", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

    }
}
